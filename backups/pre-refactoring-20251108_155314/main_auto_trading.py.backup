"""
í‚¤ì›€ ì¡°ê±´ì‹ â†’ VWAP í•„í„°ë§ â†’ ì‹¤ì‹œê°„ ìë™ë§¤ë§¤ í†µí•© ì‹œìŠ¤í…œ

ì „ì²´ í”Œë¡œìš°:
1. ì¡°ê±´ì‹ 6ê°œë¡œ 1ì°¨ í•„í„°ë§ (50~100ê°œ ì¢…ëª©)
2. VWAP ì‚¬ì „ ê²€ì¦ìœ¼ë¡œ 2ì°¨ í•„í„°ë§ (5~20ê°œ ì¢…ëª©)
3. ì„ ì • ì¢…ëª© ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
4. VWAP ë§¤ìˆ˜ ì‹ í˜¸ ê°ì§€ â†’ ì‚¬ì „ ê²€ì¦ â†’ ìë™ ë§¤ìˆ˜
5. ë³´ìœ  ì¤‘ ëª¨ë‹ˆí„°ë§ â†’ VWAP ë§¤ë„ ì‹ í˜¸ ë˜ëŠ” íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ â†’ ìë™ ë§¤ë„
6. ë¬´í•œ ë£¨í”„ (Ctrl+Cë¡œ ì¤‘ì§€)
"""
import asyncio
import websockets
import json
import sys
import os
import signal
from datetime import datetime, timedelta
from typing import List, Dict, Set
from pathlib import Path

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê²½ë¡œ
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from kiwoom_api import KiwoomAPI
from analyzers.pre_trade_validator import PreTradeValidator
from analyzers.entry_timing_analyzer import EntryTimingAnalyzer
from utils.config_loader import load_config
from database.trading_db import TradingDatabase
from dotenv import load_dotenv
import yfinance as yf
import pandas as pd
import time
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.live import Live
from rich import box

# í™˜ê²½ë³€ìˆ˜ ë¡œë“œ
load_dotenv()

# WebSocket URL
SOCKET_URL = 'wss://api.kiwoom.com:10000/api/dostk/websocket'

console = Console()


def download_stock_data(ticker: str, days: int = 7):
    """ì£¼ì‹ ë°ì´í„° ë‹¤ìš´ë¡œë“œ (5ë¶„ë´‰)"""
    try:
        import warnings
        warnings.filterwarnings('ignore')  # Yahoo Finance ê²½ê³  ë©”ì‹œì§€ ìˆ¨ê¹€

        stock = yf.Ticker(ticker)
        df = stock.history(period=f"{days}d", interval="5m")

        if df.empty:
            return None

        df.reset_index(inplace=True)
        df.columns = [col.lower() for col in df.columns]
        return df

    except Exception as e:
        return None


def validate_stock_for_trading(stock_code: str, stock_name: str, validator: PreTradeValidator):
    """ì¢…ëª© ì‚¬ì „ ê²€ì¦ (ë§¤ìˆ˜ ì „)"""
    try:
        ticker = f"{stock_code}.KS"
        df = download_stock_data(ticker, days=7)

        if df is None or len(df) < 100:
            return {'allowed': False, 'reason': 'ë°ì´í„° ë¶€ì¡±'}

        current_price = df['close'].iloc[-1]
        current_time = datetime.now()

        allowed, reason, stats = validator.validate_trade(
            stock_code=stock_code,
            stock_name=stock_name,
            historical_data=df,
            current_price=current_price,
            current_time=current_time
        )

        return {
            'allowed': allowed,
            'reason': reason,
            'stats': stats,
            'data': df
        }

    except Exception as e:
        return {'allowed': False, 'reason': f'ì˜¤ë¥˜: {str(e)}'}


class IntegratedTradingSystem:
    """í†µí•© ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ"""

    def __init__(self, access_token: str, api: KiwoomAPI, condition_indices: List[int]):
        self.uri = SOCKET_URL
        self.access_token = access_token
        self.api = api
        self.condition_indices = condition_indices

        # ì„¤ì • ë¡œë“œ
        self.config = load_config("config/strategy_hybrid.yaml")

        # ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”
        self.db = TradingDatabase("data/trading.db")
        console.print("[dim]âœ“ ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì™„ë£Œ[/dim]")

        # VWAP ê²€ì¦ê¸°
        self.validator = PreTradeValidator(
            config=self.config,
            lookback_days=5,
            min_trades=2,
            min_win_rate=50.0,
            min_avg_profit=0.5,
            min_profit_factor=1.2
        )

        # VWAP ë¶„ì„ê¸°
        analyzer_config = self.config.get_analyzer_config()
        self.analyzer = EntryTimingAnalyzer(**analyzer_config)

        # WebSocket
        self.websocket = None
        self.connected = False
        self.running = True

        # ì¢…ëª© ê´€ë¦¬
        self.condition_list = []
        self.watchlist: Set[str] = set()  # ëª¨ë‹ˆí„°ë§ ëŒ€ìƒ
        self.validated_stocks: Dict[str, Dict] = {}  # ê²€ì¦ í†µê³¼ ì¢…ëª© ìƒì„¸ ì •ë³´

        # í¬ì§€ì…˜ ê´€ë¦¬
        self.positions: Dict[str, Dict] = {}  # {stock_code: position_info}

        # ì‹¤ì‹œê°„ ë°ì´í„° ìºì‹œ
        self.price_cache: Dict[str, float] = {}

        # ê³„ì¢Œ ì •ë³´ (ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸)
        self.current_cash = 0.0
        self.total_assets = 0.0
        self.positions_value = 0.0

        # ë¦¬ìŠ¤í¬ ê´€ë¦¬ì (ë‚˜ì¤‘ì— ì‹¤ê³„ì¢Œ ê¸°ë°˜ìœ¼ë¡œ ì´ˆê¸°í™”)
        self.risk_manager = None

    async def connect(self):
        """WebSocket ì—°ê²°"""
        try:
            self.websocket = await websockets.connect(self.uri)
            self.connected = True
            console.print("=" * 120, style="bold green")
            console.print(f"{'í‚¤ì›€ í†µí•© ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ':^120}", style="bold green")
            console.print("=" * 120, style="bold green")
            console.print()
        except Exception as e:
            console.print(f"[red]âŒ WebSocket ì—°ê²° ì‹¤íŒ¨: {e}[/red]")
            raise

    async def send_message(self, trnm: str, data: dict = None):
        """WebSocket ë©”ì‹œì§€ ì „ì†¡"""
        if not self.websocket or not self.connected:
            raise Exception("WebSocketì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

        message = {"trnm": trnm}
        if data:
            message.update(data)

        await self.websocket.send(json.dumps(message))

    async def receive_message(self):
        """WebSocket ë©”ì‹œì§€ ìˆ˜ì‹ """
        if not self.websocket or not self.connected:
            raise Exception("WebSocketì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

        message = await self.websocket.recv()
        return json.loads(message)

    async def login(self):
        """WebSocket ë¡œê·¸ì¸"""
        console.print(f"[{datetime.now().strftime('%H:%M:%S')}] WebSocket ë¡œê·¸ì¸")

        login_packet = {'trnm': 'LOGIN', 'token': self.access_token}
        await self.websocket.send(json.dumps(login_packet))

        response = await self.receive_message()

        if response.get("return_code") == 0:
            console.print("âœ… ë¡œê·¸ì¸ ì„±ê³µ", style="green")
            console.print()
            return True
        else:
            console.print(f"[red]âŒ ë¡œê·¸ì¸ ì‹¤íŒ¨: {response.get('return_msg')}[/red]")
            return False

    async def initialize_account(self):
        """ê³„ì¢Œ ì •ë³´ ì´ˆê¸°í™” (ì‹œìŠ¤í…œ ì‹œì‘ ì‹œ)"""
        from core.risk_manager import RiskManager

        console.print()
        console.print("=" * 120, style="bold cyan")
        console.print(f"{'ê³„ì¢Œ ì •ë³´ ì¡°íšŒ':^120}", style="bold cyan")
        console.print("=" * 120, style="bold cyan")

        try:
            # 1. ê³„ì¢Œ ì”ê³  ì¡°íšŒ (API-ID: kt00001)
            balance_info = self.api.get_balance()

            # ì˜ˆìˆ˜ê¸ˆ íŒŒì‹± (15ìë¦¬ ë¬¸ìì—´ â†’ ìˆ«ì)
            cash_str = balance_info.get('entr', '000000000000000')
            self.current_cash = float(cash_str)

            # 2. ë³´ìœ  ì¢…ëª© ì¡°íšŒ (API-ID: ka01690)
            account_info = self.api.get_account_info()
            positions = account_info.get('day_bal_rt', [])

            # 3. ë³´ìœ  í¬ì§€ì…˜ í‰ê°€ì•¡ ê³„ì‚°
            self.positions_value = 0.0
            for pos in positions:
                # ë¹ˆ ì¢…ëª©ì€ ìŠ¤í‚µ
                if not pos.get('stk_cd') or pos.get('stk_cd') == '':
                    continue

                cur_prc = int(pos.get('cur_prc', 0)) if pos.get('cur_prc') else 0
                rmnd_qty = int(pos.get('rmnd_qty', 0)) if pos.get('rmnd_qty') else 0
                self.positions_value += cur_prc * rmnd_qty

            # 4. ì´ ìì‚°
            self.total_assets = self.current_cash + self.positions_value

            # 4. ê³„ì¢Œ ì •ë³´ ì¶œë ¥
            table = Table(title="ğŸ’° ê³„ì¢Œ í˜„í™©", box=box.ROUNDED, show_header=True, header_style="bold magenta")
            table.add_column("í•­ëª©", style="cyan", width=20)
            table.add_column("ê¸ˆì•¡", style="yellow", justify="right", width=20)

            table.add_row("ê³„ì¢Œë²ˆí˜¸", self.api.account_number)
            table.add_row("ì˜ˆìˆ˜ê¸ˆ", f"{self.current_cash:,.0f}ì›")
            table.add_row("ë³´ìœ ì¢…ëª© í‰ê°€", f"{self.positions_value:,.0f}ì›")
            table.add_row("ì´ ìì‚°", f"{self.total_assets:,.0f}ì›")
            table.add_row("ë³´ìœ ì¢…ëª© ìˆ˜", f"{len(positions)}ê°œ")

            console.print(table)
            console.print()

            # 5. ë³´ìœ  í¬ì§€ì…˜ ë¡œë“œ
            if positions:
                console.print("[bold]ë³´ìœ  í¬ì§€ì…˜:[/bold]")
                for pos in positions:
                    # ë¹ˆ ì¢…ëª©ì€ ìŠ¤í‚µ
                    stock_code = pos.get('stk_cd', '')
                    if not stock_code or stock_code == '':
                        continue

                    stock_name = pos.get('stk_nm', '')
                    quantity = int(pos.get('rmnd_qty', 0)) if pos.get('rmnd_qty') else 0
                    avg_price = int(pos.get('buy_uv', 0)) if pos.get('buy_uv') else 0
                    current_price = int(pos.get('cur_prc', 0)) if pos.get('cur_prc') else 0
                    profit_rate = float(pos.get('prft_rt', 0)) if pos.get('prft_rt') else 0.0

                    self.positions[stock_code] = {
                        'stock_name': stock_name,
                        'quantity': quantity,
                        'avg_price': avg_price,
                        'current_price': current_price,
                        'profit_rate': profit_rate,
                        'eval_amount': quantity * current_price
                    }

                    console.print(f"  â€¢ {stock_name}({stock_code}): {quantity}ì£¼ @ {current_price:,}ì› "
                                f"[{'green' if profit_rate >= 0 else 'red'}]{profit_rate:+.2f}%[/]")
                console.print()

            # 6. ë¦¬ìŠ¤í¬ ê´€ë¦¬ì ì´ˆê¸°í™” (ì‹¤ì œ ì”ê³  ê¸°ë°˜)
            self.risk_manager = RiskManager(
                initial_balance=self.current_cash,
                storage_path='data/risk_log.json'
            )

            console.print(f"[green]âœ“ ë¦¬ìŠ¤í¬ ê´€ë¦¬ì ì´ˆê¸°í™” ì™„ë£Œ (ì´ˆê¸° ì”ê³ : {self.current_cash:,.0f}ì›)[/green]")
            console.print()

        except Exception as e:
            console.print(f"[red]âŒ ê³„ì¢Œ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}[/red]")
            console.print("[yellow]âš ï¸  ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤ (10,000,000ì›)[/yellow]")

            # ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”
            self.current_cash = 10000000
            self.positions_value = 0
            self.total_assets = 10000000

            self.risk_manager = RiskManager(
                initial_balance=self.current_cash,
                storage_path='data/risk_log.json'
            )
            console.print()

    async def update_account_balance(self):
        """ê±°ë˜ í›„ ì‹¤ì‹œê°„ ì”ê³  ì—…ë°ì´íŠ¸"""
        try:
            # 1. ê³„ì¢Œ ì”ê³  ì¡°íšŒ (API-ID: kt00001)
            balance_info = self.api.get_balance()
            cash_str = balance_info.get('entr', str(int(self.current_cash)).zfill(15))
            self.current_cash = float(cash_str)

            # 2. ë³´ìœ  ì¢…ëª© ì¡°íšŒ (API-ID: ka01690)
            account_info = self.api.get_account_info()
            positions = account_info.get('day_bal_rt', [])

            # 3. ë³´ìœ  í¬ì§€ì…˜ í‰ê°€ì•¡ ê³„ì‚°
            self.positions_value = 0.0
            for pos in positions:
                if not pos.get('stk_cd') or pos.get('stk_cd') == '':
                    continue

                cur_prc = int(pos.get('cur_prc', 0)) if pos.get('cur_prc') else 0
                rmnd_qty = int(pos.get('rmnd_qty', 0)) if pos.get('rmnd_qty') else 0
                self.positions_value += cur_prc * rmnd_qty

            # 4. ì´ ìì‚°
            self.total_assets = self.current_cash + self.positions_value

            # 5. ë¦¬ìŠ¤í¬ ê´€ë¦¬ì ì”ê³  ì—…ë°ì´íŠ¸
            if self.risk_manager:
                self.risk_manager.update_balance(self.current_cash)

            console.print(f"[dim]ğŸ’° ì”ê³  ì—…ë°ì´íŠ¸: {self.current_cash:,.0f}ì› (ì´ìì‚°: {self.total_assets:,.0f}ì›)[/dim]")

        except Exception as e:
            console.print(f"[yellow]âš ï¸  ì”ê³  ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}[/yellow]")

    async def get_condition_list(self):
        """ì¡°ê±´ê²€ìƒ‰ì‹ ëª©ë¡ ì¡°íšŒ"""
        console.print("[1] ì¡°ê±´ê²€ìƒ‰ì‹ ëª©ë¡ ì¡°íšŒ")
        console.print()

        await self.send_message("CNSRLST")
        response = await self.receive_message()

        if response.get("return_code") == 0:
            self.condition_list = response.get("data", [])
            console.print(f"âœ… ì´ {len(self.condition_list)}ê°œ ì¡°ê±´ê²€ìƒ‰ì‹ ë¡œë“œ", style="green")
            console.print()

            # "ì „ëµ" í‚¤ì›Œë“œê°€ í¬í•¨ëœ ì¡°ê±´ì‹ë§Œ ìë™ ì„ íƒ
            strategy_conditions = []
            console.print("ğŸ¯ ì „ëµ ì¡°ê±´ì‹ ìë™ ì„ íƒ:", style="bold cyan")
            for i, condition in enumerate(self.condition_list):
                seq = condition[0] if len(condition) > 0 else "?"
                name = condition[1] if len(condition) > 1 else "?"

                # "ì „ëµ" í‚¤ì›Œë“œê°€ í¬í•¨ëœ ì¡°ê±´ì‹
                if "ì „ëµ" in name:
                    strategy_conditions.append(i)
                    console.print(f"  âœ“ [{i}] {name} (seq: {seq})", style="green")

            console.print()
            console.print(f"ğŸ“Š ì´ {len(strategy_conditions)}ê°œ ì „ëµ ì¡°ê±´ì‹ ì„ íƒë¨: {strategy_conditions}", style="bold yellow")
            console.print()

            # ì„ íƒëœ ì¸ë±ìŠ¤ë¥¼ condition_indicesì— ìë™ ì„¤ì •
            if hasattr(self, 'condition_indices') and len(self.condition_indices) == 0:
                self.condition_indices = strategy_conditions
                console.print(f"[cyan]ìë™ìœ¼ë¡œ ì„¤ì •ëœ ì¸ë±ìŠ¤: {self.condition_indices}[/cyan]")
                console.print()

            return True
        else:
            console.print(f"[red]âŒ ì¡°ê±´ê²€ìƒ‰ì‹ ì¡°íšŒ ì‹¤íŒ¨[/red]")
            return False

    async def search_condition(self, seq: str, name: str):
        """ì¡°ê±´ê²€ìƒ‰ ì‹¤í–‰"""
        try:
            await self.send_message("CNSRREQ", {
                "seq": seq,
                "search_type": "1",
                "stex_tp": "K"
            })
            response = await self.receive_message()

            if response is None:
                console.print(f"[yellow]âš ï¸  ì‘ë‹µ ì—†ìŒ (íƒ€ì„ì•„ì›ƒ)[/yellow]")
                return []

            if response.get("return_code") == 0:
                stock_list = response.get("data", [])

                # None ì²´í¬
                if stock_list is None:
                    console.print(f"[yellow]âš ï¸  ì¢…ëª© ë°ì´í„° ì—†ìŒ[/yellow]")
                    return []

                stock_codes = [s.get("jmcode", "").replace("A", "") for s in stock_list]
                stock_codes = [code for code in stock_codes if code]
                return stock_codes
            else:
                console.print(f"[yellow]âš ï¸  ì˜¤ë¥˜: {response.get('return_msg', 'Unknown')}[/yellow]")
                return []
        except Exception as e:
            console.print(f"[red]âŒ ì¡°ê±´ê²€ìƒ‰ ì˜¤ë¥˜: {e}[/red]")
            return []

    async def run_condition_filtering(self):
        """1ì°¨ + 2ì°¨ í•„í„°ë§ ì‹¤í–‰"""
        console.print()
        console.print("=" * 120, style="bold cyan")
        console.print(f"{'1ë‹¨ê³„: ì¡°ê±´ì‹ ê²€ìƒ‰ (1ì°¨ í•„í„°ë§)':^120}", style="bold cyan")
        console.print("=" * 120, style="bold cyan")
        console.print()

        # ì¡°ê±´ì‹ ê²€ìƒ‰
        all_stocks = set()
        filter_time = datetime.now()

        for idx in self.condition_indices:
            if idx < len(self.condition_list):
                condition = self.condition_list[idx]
                seq = condition[0]
                name = condition[1]

                console.print(f"  ğŸ” {name} ê²€ìƒ‰ ì¤‘...")
                stocks = await self.search_condition(seq, name)
                all_stocks.update(stocks)
                console.print(f"     â†’ {len(stocks)}ê°œ ë°œê²¬")

                # 1ì°¨ í•„í„°ë§ ê²°ê³¼ DBì— ì €ì¥
                filter_data = {
                    'filter_time': filter_time.isoformat(),
                    'filter_type': '1ì°¨',
                    'condition_name': name,
                    'stocks_found': len(stocks),
                    'stock_codes': list(stocks),
                    'stocks_passed': 0,
                    'stocks_failed': 0,
                    'passed_stocks': [],
                    'schedule_type': 'manual',
                    'is_new_stock': 0
                }
                self.db.insert_filter_history(filter_data)

                await asyncio.sleep(0.5)

        unique_stocks = list(all_stocks)

        console.print()
        console.print(f"ğŸ“Š ì¤‘ë³µ ì œê±° í›„ ì´ {len(unique_stocks)}ê°œ ì¢…ëª©", style="bold green")
        console.print()

        # 2ì°¨ í•„í„°ë§
        console.print("=" * 120, style="bold yellow")
        console.print(f"{'2ë‹¨ê³„: VWAP ì‚¬ì „ ê²€ì¦ (2ì°¨ í•„í„°ë§)':^120}", style="bold yellow")
        console.print("=" * 120, style="bold yellow")
        console.print()

        BATCH_SIZE = 5
        DELAY_BETWEEN_REQUESTS = 0.2
        DELAY_BETWEEN_BATCHES = 1.0

        # ì¢…ëª©ëª… ì¡°íšŒ
        stock_info_list = []
        console.print(f"[cyan]ğŸ“‹ ì¢…ëª©ëª… ì¡°íšŒ ì¤‘... (ì´ {len(unique_stocks)}ê°œ)[/cyan]")

        for i, code in enumerate(unique_stocks, 1):
            try:
                result = self.api.get_stock_info(stock_code=code)
                if result.get('return_code') == 0:
                    stock_name = result.get('stk_nm', code)  # ì˜¬ë°”ë¥¸ í•„ë“œëª…: stk_nm
                else:
                    stock_name = code
                stock_info_list.append((code, stock_name))

                if i % 10 == 0:
                    console.print(f"  {i}/{len(unique_stocks)} ì™„ë£Œ...", style="dim")

                await asyncio.sleep(DELAY_BETWEEN_REQUESTS)

                if i % BATCH_SIZE == 0:
                    await asyncio.sleep(DELAY_BETWEEN_BATCHES)

            except KeyboardInterrupt:
                console.print()
                console.print("[yellow]âš ï¸  ì‚¬ìš©ìê°€ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤. ì§€ê¸ˆê¹Œì§€ ì¡°íšŒí•œ ì¢…ëª©ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤.[/yellow]")
                break
            except Exception as e:
                stock_info_list.append((code, code))
                await asyncio.sleep(DELAY_BETWEEN_REQUESTS)

        console.print(f"[green]âœ… ì¢…ëª©ëª… ì¡°íšŒ ì™„ë£Œ[/green]")
        console.print()

        # VWAP ê²€ì¦
        console.print(f"[cyan]ğŸ” VWAP ê²€ì¦ ì‹œì‘...[/cyan]")
        console.print()

        validated_count = 0
        for i, (code, name) in enumerate(stock_info_list, 1):
            try:
                if i % 5 == 0:
                    console.print(f"  ì§„í–‰: {i}/{len(stock_info_list)}", style="dim")

                result = validate_stock_for_trading(code, name, self.validator)

                # DBì— ê²€ì¦ ì ìˆ˜ ì €ì¥
                stats = result.get('stats', {})
                score_data = {
                    'stock_code': code,
                    'stock_name': name,
                    'validation_time': datetime.now().isoformat(),
                    'vwap_win_rate': stats.get('win_rate'),
                    'vwap_avg_profit': stats.get('avg_profit_pct'),
                    'vwap_trade_count': stats.get('total_trades'),
                    'vwap_profit_factor': stats.get('profit_factor'),
                    'vwap_max_profit': stats.get('max_profit_pct'),
                    'vwap_max_loss': stats.get('max_loss_pct'),
                    'news_sentiment_score': None,  # TODO: ë‰´ìŠ¤ ë¶„ì„ ì—°ë™
                    'news_impact_type': None,
                    'news_keywords': [],
                    'news_titles': [],
                    'news_count': 0,
                    'total_score': stats.get('avg_profit_pct', 0),  # ì„ì‹œ: VWAP ì ìˆ˜ë§Œ
                    'weight_vwap': 1.0,  # ì„ì‹œ: VWAPë§Œ ì‚¬ìš©
                    'weight_news': 0.0,
                    'is_passed': 1 if result.get('allowed') else 0
                }
                self.db.insert_validation_score(score_data)

                if result.get('allowed'):
                    self.watchlist.add(code)
                    self.validated_stocks[code] = {
                        'name': name,
                        'stats': stats,
                        'data': result.get('data')
                    }
                    validated_count += 1
                    console.print(
                        f"  âœ… {name}: ìŠ¹ë¥  {stats.get('win_rate', 0):.1f}%, "
                        f"ìˆ˜ìµ {stats.get('avg_profit_pct', 0):+.1f}%",
                        style="green"
                    )

                if i % BATCH_SIZE == 0:
                    await asyncio.sleep(DELAY_BETWEEN_BATCHES)

            except KeyboardInterrupt:
                console.print()
                console.print("[yellow]âš ï¸  ì‚¬ìš©ìê°€ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤. ì§€ê¸ˆê¹Œì§€ ê²€ì¦í•œ ì¢…ëª©ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤.[/yellow]")
                break
            except Exception as e:
                console.print(f"[red]ê²€ì¦ ì˜¤ë¥˜ ({code}): {e}[/red]", style="dim")
                continue

        console.print()
        console.print("=" * 120, style="bold magenta")
        console.print(f"{'ğŸ“Š í•„í„°ë§ ê²°ê³¼ ìš”ì•½':^120}", style="bold magenta")
        console.print("=" * 120, style="bold magenta")
        console.print()
        console.print(f"  1ì°¨ í•„í„°ë§ (ì¡°ê±´ì‹ ê²€ìƒ‰): {len(unique_stocks)}ê°œ ì¢…ëª© ë°œê²¬", style="cyan")
        console.print(f"  2ì°¨ í•„í„°ë§ (VWAP ê²€ì¦): {validated_count}ê°œ í†µê³¼, {len(stock_info_list) - validated_count}ê°œ íƒˆë½", style="yellow")
        console.print(f"  ìµœì¢… ì„ ì • ì¢…ëª©: {validated_count}ê°œ", style="bold green" if validated_count > 0 else "bold red")
        console.print()

        # ìµœì¢… ì„ ì • ì¢…ëª© í‘œì‹œ
        if self.watchlist:
            table = Table(title="ìµœì¢… ì„ ì • ì¢…ëª© (ëª¨ë‹ˆí„°ë§ ëŒ€ìƒ)", box=box.DOUBLE)
            table.add_column("ìˆœìœ„", style="cyan", justify="right")
            table.add_column("ì¢…ëª©ëª…", style="yellow")
            table.add_column("ì½”ë“œ", style="dim")
            table.add_column("ìŠ¹ë¥ ", justify="right")
            table.add_column("í‰ê· ìˆ˜ìµë¥ ", justify="right", style="green")
            table.add_column("ê±°ë˜ìˆ˜", justify="right")

            sorted_stocks = sorted(
                self.validated_stocks.items(),
                key=lambda x: x[1]['stats']['avg_profit_pct'],
                reverse=True
            )

            for rank, (code, info) in enumerate(sorted_stocks, 1):
                stats = info['stats']
                table.add_row(
                    str(rank),
                    info['name'],
                    code,
                    f"{stats['win_rate']:.1f}%",
                    f"{stats['avg_profit_pct']:+.2f}%",
                    f"{stats['total_trades']}íšŒ"
                )

            console.print(table)
            console.print()

    def is_market_open(self) -> bool:
        """ì¥ ìš´ì˜ ì‹œê°„ ì²´í¬ (í‰ì¼ 09:00 ~ 15:30)"""
        now = datetime.now()

        # ì£¼ë§ ì²´í¬
        if now.weekday() >= 5:  # í† ìš”ì¼(5), ì¼ìš”ì¼(6)
            return False

        # ì¥ ì‹œê°„ ì²´í¬ (09:00 ~ 15:30)
        market_open = now.replace(hour=9, minute=0, second=0, microsecond=0)
        market_close = now.replace(hour=15, minute=30, second=0, microsecond=0)

        return market_open <= now <= market_close

    async def monitor_and_trade(self):
        """ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ë° ë§¤ë§¤ (5ë¶„ë§ˆë‹¤ ì¡°ê±´ê²€ìƒ‰ ì¬ì‹¤í–‰)"""
        console.print("=" * 120, style="bold magenta")
        console.print(f"{'3ë‹¨ê³„: ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘':^120}", style="bold magenta")
        console.print("=" * 120, style="bold magenta")
        console.print()

        console.print(f"ğŸ¯ ì´ˆê¸° ëª¨ë‹ˆí„°ë§ ëŒ€ìƒ: {len(self.watchlist)}ê°œ ì¢…ëª©")
        console.print(f"â° ì‹œì‘ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        console.print(f"ğŸ”„ 5ë¶„ë§ˆë‹¤ ì¡°ê±´ê²€ìƒ‰ ì¬ì‹¤í–‰ â†’ ìƒˆ ì¢…ëª© ìë™ ì¶”ê°€")
        console.print()

        # ì¥ ì‹œê°„ ì²´í¬
        if not self.is_market_open():
            console.print("[yellow]âš ï¸  í˜„ì¬ ì¥ ìš´ì˜ ì‹œê°„ì´ ì•„ë‹™ë‹ˆë‹¤.[/yellow]")
            console.print("[yellow]   í‰ì¼ 09:00 ~ 15:30ì—ë§Œ ëª¨ë‹ˆí„°ë§ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.[/yellow]")
            console.print()
            console.print("[cyan]ğŸ’¡ ì¥ ì‹œì‘ ì‹œê°„ê¹Œì§€ ëŒ€ê¸°í•©ë‹ˆë‹¤...[/cyan]")
            console.print("[dim]Ctrl+Cë¥¼ ëˆŒëŸ¬ ì¢…ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.[/dim]")
            console.print()
        else:
            console.print("[cyan]âœ… ì¥ì´ ì—´ë ¤ìˆìŠµë‹ˆë‹¤. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘...[/cyan]")
            console.print("[dim]Ctrl+Cë¥¼ ëˆŒëŸ¬ ì¢…ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.[/dim]")
            console.print()

        check_interval = 60  # 1ë¶„ë§ˆë‹¤ ì¢…ëª© ì²´í¬
        rescan_interval = 300  # 5ë¶„ë§ˆë‹¤ ì¡°ê±´ê²€ìƒ‰ ì¬ì‹¤í–‰

        last_check = datetime.now()
        last_rescan = datetime.now()
        last_status_update = datetime.now()

        try:
            while self.running:
                current_time = datetime.now()

                # ì¥ ì‹œê°„ì¸ì§€ ì²´í¬
                if self.is_market_open():
                    # 5ë¶„ë§ˆë‹¤ ì¡°ê±´ê²€ìƒ‰ ì¬ì‹¤í–‰
                    if (current_time - last_rescan).seconds >= rescan_interval:
                        console.print()
                        console.print("[cyan]ğŸ”„ 5ë¶„ ê²½ê³¼ - ì¡°ê±´ê²€ìƒ‰ ì¬ì‹¤í–‰ ì¤‘...[/cyan]")
                        await self.rescan_and_add_stocks()
                        last_rescan = current_time
                        console.print(f"[green]âœ… í˜„ì¬ ëª¨ë‹ˆí„°ë§ ì¢…ëª©: {len(self.watchlist)}ê°œ[/green]")
                        console.print()

                    # 1ë¶„ë§ˆë‹¤ ì¢…ëª© ì²´í¬
                    elif (current_time - last_check).seconds >= check_interval:
                        self.check_all_stocks()
                        last_check = current_time
                    else:
                        # ë‚¨ì€ ì‹œê°„ ì¹´ìš´íŠ¸ë‹¤ìš´ (ê°™ì€ ì¤„ì—ì„œ ê°±ì‹ )
                        elapsed = (current_time - last_check).seconds
                        remaining = check_interval - elapsed

                        # ë‹¤ìŒ ì¬ê²€ìƒ‰ê¹Œì§€ ë‚¨ì€ ì‹œê°„ë„ í‘œì‹œ
                        rescan_elapsed = (current_time - last_rescan).seconds
                        rescan_remaining = rescan_interval - rescan_elapsed
                        rescan_min = rescan_remaining // 60
                        rescan_sec = rescan_remaining % 60

                        import sys
                        sys.stdout.write(f"\rë‹¤ìŒ ì²´í¬: {remaining}ì´ˆ í›„ | ë‹¤ìŒ ì¬ê²€ìƒ‰: {rescan_min}ë¶„ {rescan_sec}ì´ˆ í›„ | Ctrl+C: ì¢…ë£Œ   ")
                        sys.stdout.flush()
                else:
                    # ì¥ ì‹œê°„ì´ ì•„ë‹ˆë©´ 1ë¶„ë§ˆë‹¤ ìƒíƒœ ì—…ë°ì´íŠ¸ (ê°™ì€ ì¤„ì—)
                    if (current_time - last_status_update).seconds >= 60:
                        # ê°™ì€ ì¤„ì—ì„œ ì—…ë°ì´íŠ¸
                        console.print(f"\r[dim]{current_time.strftime('%H:%M:%S')} - ì¥ ì‹œê°„ ì•„ë‹˜, ëŒ€ê¸° ì¤‘...[/dim]", end="")
                        last_status_update = current_time

                # asyncio.sleep ì‚¬ìš© (KeyboardInterrupt ê°ì§€ ê°€ëŠ¥)
                await asyncio.sleep(1)

        except KeyboardInterrupt:
            console.print()
            console.print("[yellow]âš ï¸  ì‚¬ìš©ìê°€ ì¤‘ì§€ë¥¼ ìš”ì²­í–ˆìŠµë‹ˆë‹¤.[/yellow]")
            self.shutdown()

    def check_all_stocks(self):
        """ëª¨ë“  ì¢…ëª© ì²´í¬ ë° ì‹¤ì‹œê°„ í…Œì´ë¸” ê°±ì‹  (ë§¤ìˆ˜ ì¡°ê±´ ì¤‘ì‹¬)"""
        import sys
        from rich.table import Table
        from rich.live import Live

        current_time = datetime.now().strftime('%H:%M:%S')

        # ì¢…ëª©ë³„ ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì§‘
        stock_data = []

        for stock_code in self.watchlist:
            try:
                stock_info = self.validated_stocks.get(stock_code)
                if not stock_info:
                    console.print(f"[dim]âš ï¸  {stock_code}: validated_stocksì— ì—†ìŒ[/dim]")
                    continue

                # í˜„ì¬ê°€ ì¡°íšŒ
                ticker = f"{stock_code}.KS"
                df = download_stock_data(ticker, days=1)

                if df is None or len(df) < 20:
                    console.print(f"[dim]âš ï¸  {stock_code}: ë°ì´í„° ë¶€ì¡± (len={len(df) if df is not None else 0})[/dim]")
                    continue

                # VWAP, MA20, ATR ê³„ì‚°
                df = self.analyzer.calculate_vwap(df)
                df['ma20'] = df['close'].rolling(window=20).mean()
                df['volume_ma20'] = df['volume'].rolling(window=20).mean()

                current_price = df['close'].iloc[-1]
                current_vwap = df['vwap'].iloc[-1]
                current_ma20 = df['ma20'].iloc[-1]
                current_volume = df['volume'].iloc[-1]
                avg_volume = df['volume_ma20'].iloc[-1]

                # ê±°ë˜ëŸ‰ ì¦ê°ë¥ 
                volume_change_pct = ((current_volume - avg_volume) / avg_volume * 100) if avg_volume > 0 else 0

                # ë§¤ìˆ˜ ì¡°ê±´ ì²´í¬
                condition_vwap = current_price > current_vwap  # VWAP ìœ„
                condition_ma20 = current_price > current_ma20  # MA20 ìœ„ (ìƒìŠ¹ì¶”ì„¸)
                condition_volume = volume_change_pct > 20      # ê±°ë˜ëŸ‰ 20% ì´ìƒ ì¦ê°€

                # ì‹œê·¸ë„ íŒë‹¨
                conditions_met = sum([condition_vwap, condition_ma20, condition_volume])

                if conditions_met == 3:
                    signal = "âœ… ë§¤ìˆ˜"
                    signal_color = "green"
                elif conditions_met >= 2:
                    signal = "â³ ëŒ€ê¸°"
                    signal_color = "yellow"
                else:
                    signal = "âŒ ì œì™¸"
                    signal_color = "red"

                stock_data.append({
                    'code': stock_code,
                    'name': stock_info['name'],
                    'price': current_price,
                    'vwap': current_vwap,
                    'vwap_ok': condition_vwap,
                    'ma20': current_ma20,
                    'ma20_ok': condition_ma20,
                    'volume_change_pct': volume_change_pct,
                    'volume_ok': condition_volume,
                    'signal': signal,
                    'signal_color': signal_color,
                    'conditions_met': conditions_met,
                    'time': current_time
                })

                # ë§¤ìˆ˜/ë§¤ë„ ì‹ í˜¸ ì²´í¬ (ê¸°ì¡´ ë¡œì§)
                if stock_code in self.positions:
                    self.check_exit_signal(stock_code)
                else:
                    self.check_entry_signal(stock_code)

            except Exception as e:
                console.print(f"[red]âŒ {stock_code}: {e}[/red]")
                import traceback
                traceback.print_exc()
                continue

        # ì¡°ê±´ ì¶©ì¡± ê°œìˆ˜ ìˆœ â†’ ë§¤ìˆ˜ ì‹œê·¸ë„ ìš°ì„ 
        stock_data.sort(key=lambda x: x['conditions_met'], reverse=True)

        # í™”ë©´ í´ë¦¬ì–´
        console.clear()
        console.print()

        # ì¢…ëª© ìˆ˜ í™•ì¸
        if len(stock_data) == 0:
            console.print("[yellow]âš ï¸  ëª¨ë‹ˆí„°ë§ ì¤‘ì¸ ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤.[/yellow]")
            console.print(f"[dim]watchlist: {len(self.watchlist)}ê°œ[/dim]")
            console.print(f"[dim]validated_stocks: {len(self.validated_stocks)}ê°œ[/dim]")
            return

        # ========================================
        # 1. ì‹œë®¬ë ˆì´ì…˜ í†µê³„ ìš”ì•½ í…Œì´ë¸”
        # ========================================
        sim_table = Table(title=f"ğŸ“ˆ ì‹œë®¬ë ˆì´ì…˜ í†µê³„ ìš”ì•½ ({current_time})", box=box.ROUNDED, show_header=True, header_style="bold cyan")
        sim_table.add_column("ìˆœë²ˆ", style="cyan", justify="right", width=4)
        sim_table.add_column("ì½”ë“œ", style="yellow", width=8)
        sim_table.add_column("ì¢…ëª©ëª…", style="white", width=12)
        sim_table.add_column("ì´ê±°ë˜", justify="right", width=8)
        sim_table.add_column("ìŠ¹", style="green", justify="right", width=6)
        sim_table.add_column("íŒ¨", style="red", justify="right", width=6)
        sim_table.add_column("ìŠ¹ë¥ ", justify="right", width=8)
        sim_table.add_column("í‰ê· ìˆ˜ìµ", justify="right", width=10)
        sim_table.add_column("ìµœëŒ€ìˆ˜ìµ", justify="right", width=10)
        sim_table.add_column("ìµœëŒ€ì†ì‹¤", justify="right", width=10)
        sim_table.add_column("ì¢…í•©ì ìˆ˜", justify="right", width=8)

        for i, data in enumerate(stock_data, 1):
            stock_info = self.validated_stocks.get(data['code'])
            if not stock_info:
                continue

            stats = stock_info['stats']
            total_trades = stats.get('total_trades', 0)
            winning_trades = stats.get('winning_trades', 0)
            losing_trades = stats.get('losing_trades', 0)
            win_rate = stats.get('win_rate', 0)
            avg_profit = stats.get('avg_profit_pct', 0)
            max_profit = stats.get('max_profit_pct', 0)
            max_loss = stats.get('max_loss_pct', 0)

            # ì¢…í•© ì ìˆ˜
            score = (win_rate * 0.6) + (avg_profit * 10 * 0.4)

            # ì ìˆ˜ ìƒ‰ìƒ
            score_color = "green" if score >= 70 else "yellow" if score >= 50 else "red"

            # ìŠ¹ë¥  ìƒ‰ìƒ
            wr_color = "green" if win_rate >= 60 else "yellow" if win_rate >= 40 else "red"

            # í‰ê· ìˆ˜ìµ ìƒ‰ìƒ
            avg_color = "green" if avg_profit >= 2 else "yellow" if avg_profit >= 1 else "red"

            sim_table.add_row(
                str(i),
                data['code'],
                data['name'],
                str(total_trades),
                str(winning_trades),
                str(losing_trades),
                f"[{wr_color}]{win_rate:.1f}%[/{wr_color}]",
                f"[{avg_color}]{avg_profit:+.2f}%[/{avg_color}]",
                f"[green]{max_profit:+.2f}%[/green]",
                f"[red]{max_loss:+.2f}%[/red]",
                f"[{score_color}]{score:.0f}[/{score_color}]"
            )

        console.print(sim_table)
        console.print()

        # ========================================
        # 2. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ í…Œì´ë¸” (ë§¤ìˆ˜ ì¡°ê±´)
        # ========================================
        table = Table(title=f"ğŸ“Š ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ - ë§¤ìˆ˜ ì¡°ê±´ ì²´í¬ ({current_time})", box=box.ROUNDED, show_header=True, header_style="bold magenta")
        table.add_column("ìˆœë²ˆ", style="cyan", justify="right", width=4)
        table.add_column("ì½”ë“œ", style="yellow", width=8)
        table.add_column("ì¢…ëª©ëª…", style="white", width=12)
        table.add_column("í˜„ì¬ê°€", justify="right", width=10)
        table.add_column("VWAP", justify="right", width=10)
        table.add_column("MA20", justify="right", width=10)
        table.add_column("ê±°ë˜ëŸ‰ì¦ê°", justify="right", width=10)
        table.add_column("ì‹œê·¸ë„", justify="center", width=10)
        table.add_column("ì²´í¬ì‹œê°„", style="dim", width=10)

        for i, data in enumerate(stock_data, 1):
            # VWAP ì¡°ê±´ ìƒ‰ìƒ
            vwap_str = f"{data['vwap']:,.0f}"
            if data['vwap_ok']:
                vwap_str = f"[green]{vwap_str} âœ“[/green]"
            else:
                vwap_str = f"[red]{vwap_str} âœ—[/red]"

            # MA20 ì¡°ê±´ ìƒ‰ìƒ
            ma20_str = f"{data['ma20']:,.0f}"
            if data['ma20_ok']:
                ma20_str = f"[green]{ma20_str} âœ“[/green]"
            else:
                ma20_str = f"[red]{ma20_str} âœ—[/red]"

            # ê±°ë˜ëŸ‰ ì¦ê° ìƒ‰ìƒ
            vol_change_str = f"{data['volume_change_pct']:+.1f}%"
            if data['volume_ok']:
                vol_change_str = f"[green]{vol_change_str} âœ“[/green]"
            else:
                vol_change_str = f"[red]{vol_change_str} âœ—[/red]"

            # ì‹œê·¸ë„ ìƒ‰ìƒ
            signal_color = data['signal_color']
            signal_str = f"[{signal_color}]{data['signal']}[/{signal_color}]"

            table.add_row(
                str(i),
                data['code'],
                data['name'],
                f"{data['price']:,.0f}",
                vwap_str,
                ma20_str,
                vol_change_str,
                signal_str,
                data['time']
            )

        # ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ í…Œì´ë¸” ì¶œë ¥
        console.print(table)
        console.print()
        console.print(f"[dim]ë‹¤ìŒ ì²´í¬: 60ì´ˆ í›„ | Ctrl+C: ì¢…ë£Œ[/dim]")

    def check_entry_signal(self, stock_code: str):
        """ë§¤ìˆ˜ ì‹ í˜¸ ì²´í¬"""
        try:
            stock_info = self.validated_stocks.get(stock_code)
            if not stock_info:
                return

            # ìµœì‹  ë°ì´í„° ë‹¤ìš´ë¡œë“œ
            ticker = f"{stock_code}.KS"
            df = download_stock_data(ticker, days=1)

            if df is None or len(df) < 50:
                return

            # VWAP ê³„ì‚° ë° ì‹ í˜¸ ìƒì„±
            df = self.analyzer.calculate_vwap(df)
            df = self.analyzer.calculate_atr(df)

            signal_config = self.config.get_signal_generation_config()
            df = self.analyzer.generate_signals(df, **signal_config)

            # ìµœì‹  ì‹ í˜¸ í™•ì¸
            latest_signal = df['signal'].iloc[-1]
            current_price = df['close'].iloc[-1]
            current_vwap = df['vwap'].iloc[-1]

            if latest_signal == 1:  # ë§¤ìˆ˜ ì‹ í˜¸
                # ì‚¬ì „ ê²€ì¦ ì¬í™•ì¸
                validation = validate_stock_for_trading(
                    stock_code,
                    stock_info['name'],
                    self.validator
                )

                if validation.get('allowed'):
                    self.execute_buy(stock_code, stock_info['name'], current_price, df)

        except Exception as e:
            console.print(f"[red]âŒ {stock_code} ë§¤ìˆ˜ ì‹ í˜¸ ì²´í¬ ì‹¤íŒ¨: {e}[/red]")

    def check_exit_signal(self, stock_code: str):
        """ë§¤ë„ ì‹ í˜¸ ì²´í¬"""
        try:
            position = self.positions.get(stock_code)
            if not position:
                return

            # ìµœì‹  ë°ì´í„° ë‹¤ìš´ë¡œë“œ
            ticker = f"{stock_code}.KS"
            df = download_stock_data(ticker, days=1)

            if df is None or len(df) < 50:
                return

            # VWAP ê³„ì‚° ë° ì‹ í˜¸ ìƒì„±
            df = self.analyzer.calculate_vwap(df)
            df = self.analyzer.calculate_atr(df)

            signal_config = self.config.get_signal_generation_config()
            df = self.analyzer.generate_signals(df, **signal_config)

            # ìµœì‹  ì‹ í˜¸ í™•ì¸
            latest_signal = df['signal'].iloc[-1]
            current_price = df['close'].iloc[-1]

            # ìˆ˜ìµë¥  ê³„ì‚°
            profit_pct = ((current_price - position['entry_price']) / position['entry_price']) * 100

            # ë§¤ë„ ì¡°ê±´ ì²´í¬
            should_exit = False
            exit_reason = ""

            # 1. VWAP í•˜í–¥ ëŒíŒŒ
            if latest_signal == -1:
                should_exit = True
                exit_reason = "VWAP í•˜í–¥ ëŒíŒŒ"

            # 2. íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì²´í¬
            trailing_config = self.config.get_trailing_config()
            atr = df['atr'].iloc[-1] if 'atr' in df.columns else None

            trailing_result = self.analyzer.check_trailing_stop(
                current_price=current_price,
                avg_price=position['entry_price'],
                highest_price=position.get('highest_price', position['entry_price']),
                trailing_active=position.get('trailing_active', False),
                atr=atr,
                **trailing_config
            )

            if trailing_result[0]:  # should_exit
                should_exit = True
                exit_reason = trailing_result[3]  # exit_reason

            # ë§¤ë„ ì‹¤í–‰
            if should_exit:
                self.execute_sell(stock_code, current_price, profit_pct, exit_reason)

            # ìµœê³ ê°€ ê°±ì‹ 
            if current_price > position.get('highest_price', position['entry_price']):
                position['highest_price'] = current_price

        except Exception as e:
            console.print(f"[red]âŒ {stock_code} ë§¤ë„ ì‹ í˜¸ ì²´í¬ ì‹¤íŒ¨: {e}[/red]")

    def execute_buy(self, stock_code: str, stock_name: str, price: float, df: pd.DataFrame):
        """ë§¤ìˆ˜ ì‹¤í–‰ (ì‹¤ê³„ì¢Œ ê¸°ë°˜ ë¦¬ìŠ¤í¬ ê´€ë¦¬)"""
        console.print()
        console.print("=" * 80, style="green")
        console.print(f"ğŸ”” ë§¤ìˆ˜ ì‹ í˜¸ ë°œìƒ: {stock_name} ({stock_code})", style="bold green")
        console.print(f"   ê°€ê²©: {price:,.0f}ì›")
        console.print(f"   ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

        # ì‹¤ê³„ì¢Œ ê¸°ë°˜ í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
        if not self.risk_manager:
            console.print("[red]âŒ ë¦¬ìŠ¤í¬ ê´€ë¦¬ìê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.[/red]")
            return

        # ì†ì ˆê°€ ê³„ì‚° (ì„ì‹œë¡œ -3%)
        stop_loss_price = price * 0.97

        # í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
        position_calc = self.risk_manager.calculate_position_size(
            current_balance=self.current_cash,
            current_price=price,
            stop_loss_price=stop_loss_price,
            entry_confidence=1.0
        )

        quantity = position_calc['quantity']
        amount = position_calc['investment']

        # ì§„ì… ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
        can_enter, reason = self.risk_manager.can_open_position(
            current_balance=self.current_cash,
            current_positions_value=self.positions_value,
            position_count=len(self.positions),
            position_size=amount
        )

        if not can_enter:
            console.print(f"[yellow]âš ï¸  ë§¤ìˆ˜ ë¶ˆê°€: {reason}[/yellow]")
            console.print("=" * 80, style="yellow")
            return

        console.print(f"[dim]ğŸ“Š í¬ì§€ì…˜ ê³„ì‚°:[/dim]")
        console.print(f"[dim]   - íˆ¬ìê¸ˆì•¡: {amount:,.0f}ì› (ë¦¬ìŠ¤í¬: {position_calc['risk_amount']:,.0f}ì›)[/dim]")
        console.print(f"[dim]   - ë§¤ìˆ˜ìˆ˜ëŸ‰: {quantity}ì£¼[/dim]")
        console.print(f"[dim]   - í¬ì§€ì…˜ë¹„ìœ¨: {position_calc['position_ratio']:.1f}%[/dim]")

        # í¬ì§€ì…˜ ìƒì„± (ì‹¤ì œë¡œëŠ” API í˜¸ì¶œ)
        entry_time = datetime.now()
        self.positions[stock_code] = {
            'name': stock_name,
            'entry_price': price,
            'entry_time': entry_time,
            'quantity': quantity,
            'highest_price': price,
            'trailing_active': False,
            'trade_id': None  # DB trade_id ì €ì¥ìš©
        }

        # DBì— ë§¤ìˆ˜ ê±°ë˜ ì €ì¥
        stock_info = self.validated_stocks.get(stock_code, {})
        stats = stock_info.get('stats', {})

        trade_data = {
            'stock_code': stock_code,
            'stock_name': stock_name,
            'trade_type': 'BUY',
            'trade_time': entry_time.isoformat(),
            'price': price,
            'quantity': quantity,
            'amount': amount,
            'condition_name': 'VWAP',  # TODO: ì‹¤ì œ ì¡°ê±´ì‹ ì´ë¦„
            'strategy_config': 'hybrid',
            'entry_reason': 'VWAP ìƒí–¥ ëŒíŒŒ',
            'vwap_validation_score': stats.get('avg_profit_pct', 0),
            'sim_win_rate': stats.get('win_rate'),
            'sim_avg_profit': stats.get('avg_profit_pct'),
            'sim_trade_count': stats.get('total_trades'),
            'sim_profit_factor': stats.get('profit_factor'),
            'news_sentiment': None,  # TODO: ë‰´ìŠ¤ ë¶„ì„ ì—°ë™
            'news_impact': None,
            'news_keywords': [],
            'news_titles': []
        }

        trade_id = self.db.insert_trade(trade_data)
        self.positions[stock_code]['trade_id'] = trade_id

        # ë¦¬ìŠ¤í¬ ê´€ë¦¬ìì— ê±°ë˜ ê¸°ë¡
        self.risk_manager.record_trade(
            stock_code=stock_code,
            stock_name=stock_name,
            trade_type='BUY',
            quantity=quantity,
            price=price,
            realized_pnl=0
        )

        console.print(f"âœ… ë§¤ìˆ˜ ì™„ë£Œ (DB ID: {trade_id})")
        console.print("=" * 80, style="green")
        console.print()

        # ì”ê³  ì—…ë°ì´íŠ¸ (ë¹„ë™ê¸° ì‹¤í–‰ì€ ë‚˜ì¤‘ì—)
        # TODO: asyncio.create_task(self.update_account_balance())

    def execute_sell(self, stock_code: str, price: float, profit_pct: float, reason: str):
        """ë§¤ë„ ì‹¤í–‰"""
        position = self.positions.get(stock_code)
        if not position:
            return

        holding_duration = (datetime.now() - position['entry_time']).seconds
        realized_profit = (price - position['entry_price']) * position['quantity']

        console.print()
        console.print("=" * 80, style="red")
        console.print(f"ğŸ”” ë§¤ë„ ì‹ í˜¸ ë°œìƒ: {position['name']} ({stock_code})", style="bold red")
        console.print(f"   ë§¤ìˆ˜ê°€: {position['entry_price']:,.0f}ì›")
        console.print(f"   ë§¤ë„ê°€: {price:,.0f}ì›")
        console.print(f"   ìˆ˜ìµë¥ : {profit_pct:+.2f}%")
        console.print(f"   ì‹¤í˜„ì†ìµ: {realized_profit:+,.0f}ì›")
        console.print(f"   ì‚¬ìœ : {reason}")
        console.print(f"   ë³´ìœ ì‹œê°„: {holding_duration // 60}ë¶„")

        # DBì— ë§¤ë„ ì •ë³´ ì €ì¥ (ë§¤ìˆ˜ ì‹œ ìƒì„±í•œ trade ì—…ë°ì´íŠ¸)
        trade_id = position.get('trade_id')
        if trade_id:
            # ë§¤ë„ ê±°ë˜ ì¶”ê°€ (SELL)
            sell_trade = {
                'stock_code': stock_code,
                'stock_name': position['name'],
                'trade_type': 'SELL',
                'trade_time': datetime.now().isoformat(),
                'price': price,
                'quantity': position['quantity'],
                'amount': price * position['quantity'],
                'exit_reason': reason,
                'realized_profit': realized_profit,
                'profit_rate': profit_pct,
                'holding_duration': holding_duration
            }
            self.db.insert_trade(sell_trade)

        # ë¦¬ìŠ¤í¬ ê´€ë¦¬ìì— ê±°ë˜ ê¸°ë¡
        self.risk_manager.record_trade(
            stock_code=stock_code,
            stock_name=position['name'],
            trade_type='SELL',
            quantity=position['quantity'],
            price=price,
            realized_pnl=realized_profit
        )

        # í¬ì§€ì…˜ ì œê±° (ì‹¤ì œë¡œëŠ” API í˜¸ì¶œ)
        del self.positions[stock_code]

        console.print(f"âœ… ë§¤ë„ ì™„ë£Œ")
        console.print("=" * 80, style="red")
        console.print()

        # ì”ê³  ì—…ë°ì´íŠ¸ (ë¹„ë™ê¸° ì‹¤í–‰ì€ ë‚˜ì¤‘ì—)
        # TODO: asyncio.create_task(self.update_account_balance())

    def shutdown(self):
        """ì‹œìŠ¤í…œ ì¢…ë£Œ"""
        self.running = False

        console.print()
        console.print("=" * 120, style="yellow")
        console.print(f"{'ì‹œìŠ¤í…œ ì¢…ë£Œ ì¤‘...':^120}", style="bold yellow")
        console.print("=" * 120, style="yellow")
        console.print()

        # ë¯¸ì²­ì‚° í¬ì§€ì…˜ í‘œì‹œ
        if self.positions:
            console.print(f"[yellow]âš ï¸  ë¯¸ì²­ì‚° í¬ì§€ì…˜: {len(self.positions)}ê°œ[/yellow]")

            for code, pos in self.positions.items():
                console.print(f"  - {pos['name']} ({code}): {pos['entry_price']:,.0f}ì›ì— ë§¤ìˆ˜")

            console.print()

        console.print("âœ… ì‹œìŠ¤í…œ ì¢…ë£Œ ì™„ë£Œ")

    async def wait_until_time(self, target_hour: int, target_minute: int):
        """íŠ¹ì • ì‹œê°ê¹Œì§€ ëŒ€ê¸°"""
        import sys

        # ëª©í‘œ ì‹œê°„ ê³„ì‚°
        now = datetime.now()

        if now.weekday() >= 5:  # í† ìš”ì¼(5), ì¼ìš”ì¼(6)
            # ë‹¤ìŒ ì›”ìš”ì¼ ê³„ì‚°
            days_until_monday = 7 - now.weekday()
            next_monday = now + timedelta(days=days_until_monday)
            target_time = next_monday.replace(hour=target_hour, minute=target_minute, second=0, microsecond=0)
        else:
            # í‰ì¼
            target_time = now.replace(hour=target_hour, minute=target_minute, second=0, microsecond=0)

            # ì´ë¯¸ ëª©í‘œ ì‹œê°„ì„ ì§€ë‚¬ìœ¼ë©´ ë‹¤ìŒë‚ 
            if now >= target_time:
                target_time += timedelta(days=1)
                # ê¸ˆìš”ì¼ì´ë©´ ë‹¤ìŒ ì›”ìš”ì¼ë¡œ
                if target_time.weekday() >= 5:
                    days_until_monday = 7 - target_time.weekday()
                    target_time += timedelta(days=days_until_monday)

        # ì²˜ìŒ í•œ ë²ˆë§Œ ëª©í‘œ ì‹œê°„ ì¶œë ¥
        console.print(f"[yellow]â° ëª©í‘œ: {target_time.strftime('%m/%d %H:%M')} ({target_time.strftime('%A')})[/yellow]")

        # ëŒ€ê¸° ë£¨í”„
        while True:
            now = datetime.now()
            time_diff = (target_time - now).total_seconds()

            if time_diff <= 0:
                # ì¤„ë°”ê¿ˆ í›„ ì™„ë£Œ ë©”ì‹œì§€
                print()
                console.print(f"[green]âœ“ {target_hour:02d}:{target_minute:02d} ë„ë‹¬![/green]")
                break

            hours = int(time_diff // 3600)
            minutes = int((time_diff % 3600) // 60)

            # ê°™ì€ ì¤„ì—ì„œ ì—…ë°ì´íŠ¸ (carriage return ì‚¬ìš©)
            sys.stdout.write(f"\râ° ëŒ€ê¸° ì¤‘... ë‚¨ì€ ì‹œê°„: {hours:02d}ì‹œê°„ {minutes:02d}ë¶„   ")
            sys.stdout.flush()

            # asyncio.sleep ì‚¬ìš© (KeyboardInterrupt ê°ì§€ ê°€ëŠ¥)
            await asyncio.sleep(60)

    async def daily_routine(self):
        """ì¼ì¼ ë£¨í‹´ ì‹¤í–‰ (í•˜ë£¨ì— í•œ ë²ˆë§Œ)"""
        console.print()
        console.print("=" * 120, style="bold yellow")
        console.print(f"{'ğŸ“… ì¼ì¼ ìë™ë§¤ë§¤ ë£¨í‹´ ì‹œì‘':^120}", style="bold yellow")
        console.print("=" * 120, style="bold yellow")
        console.print()

        # 1. 08:50ê¹Œì§€ ëŒ€ê¸° (ì´ë¯¸ ì§€ë‚¬ìœ¼ë©´ ë°”ë¡œ ì‹œì‘)
        now = datetime.now()
        target_time = now.replace(hour=8, minute=50, second=0, microsecond=0)

        if now < target_time:
            # ì•„ì§ 08:50 ì „ì´ë©´ ëŒ€ê¸°
            await self.wait_until_time(8, 50)
        else:
            # ì´ë¯¸ 08:50 ì§€ë‚¬ìœ¼ë©´ ë°”ë¡œ ì‹œì‘
            console.print(f"[cyan]â° í˜„ì¬ ì‹œê°„: {now.strftime('%H:%M')} - ë°”ë¡œ í•„í„°ë§ ì‹œì‘í•©ë‹ˆë‹¤.[/cyan]")
            console.print()

        try:
            # 2. WebSocket ì—°ê²° ë° ë¡œê·¸ì¸
            console.print("\n[1ë‹¨ê³„] ì‹œìŠ¤í…œ ì´ˆê¸°í™”")
            await self.connect()

            if not await self.login():
                console.print("[red]âŒ ë¡œê·¸ì¸ ì‹¤íŒ¨. ë‚´ì¼ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.[/red]")
                return

            # 3. ê³„ì¢Œ ì •ë³´ ì´ˆê¸°í™”
            await self.initialize_account()

            # 4. ì¡°ê±´ì‹ ëª©ë¡ ì¡°íšŒ
            if not await self.get_condition_list():
                console.print("[red]âŒ ì¡°ê±´ì‹ ì¡°íšŒ ì‹¤íŒ¨. ë‚´ì¼ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.[/red]")
                return

            # 5. 1ì°¨ + 2ì°¨ í•„í„°ë§ (08:50 ~ 09:00)
            console.print("\n[2ë‹¨ê³„] í•„í„°ë§ ì‹œì‘ (08:50)")
            await self.run_condition_filtering()

            # ì„ ì • ì¢…ëª©ì´ ì—†ìœ¼ë©´ ì˜¤ëŠ˜ì€ ì¢…ë£Œ
            if not self.watchlist:
                console.print("[yellow]âš ï¸  ì„ ì •ëœ ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤. ì˜¤ëŠ˜ ê±°ë˜ ì—†ìŒ.[/yellow]")
                return

            # 6. WebSocket ì¢…ë£Œ (REST APIë§Œ ì‚¬ìš©)
            if self.websocket:
                await self.websocket.close()

            # 7. 09:00ê¹Œì§€ ëŒ€ê¸° (ì´ë¯¸ ì§€ë‚¬ìœ¼ë©´ ë°”ë¡œ ì‹œì‘)
            now = datetime.now()
            market_open = now.replace(hour=9, minute=0, second=0, microsecond=0)

            if now < market_open:
                # ì•„ì§ 09:00 ì „ì´ë©´ ëŒ€ê¸°
                await self.wait_until_time(9, 0)
            else:
                # ì´ë¯¸ 09:00 ì§€ë‚¬ìœ¼ë©´ ë°”ë¡œ ì‹œì‘
                console.print(f"[cyan]â° í˜„ì¬ ì‹œê°„: {now.strftime('%H:%M')} - ë°”ë¡œ ëª¨ë‹ˆí„°ë§ ì‹œì‘í•©ë‹ˆë‹¤.[/cyan]")
                console.print()

            # 8. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ë° ë§¤ë§¤ (09:00 ~ 15:30)
            console.print("\n[3ë‹¨ê³„] ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘")
            await self.monitor_and_trade()

        except Exception as e:
            console.print(f"[red]âŒ ë£¨í‹´ ì‹¤í–‰ ì˜¤ë¥˜: {e}[/red]")
            import traceback
            traceback.print_exc()
        finally:
            # WebSocket ì •ë¦¬
            if self.websocket:
                await self.websocket.close()

    async def run(self):
        """ì „ì²´ ì‹œìŠ¤í…œ ì‹¤í–‰ (ë¬´í•œ ë°˜ë³µ)"""
        console.print()
        console.print("=" * 120, style="bold green")
        console.print(f"{'ğŸš€ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ ì‹œì‘ (ìŠ¤ì¼€ì¤„ë§ ëª¨ë“œ)':^120}", style="bold green")
        console.print("=" * 120, style="bold green")
        console.print()
        console.print("[cyan]ë§¤ì¼ 08:50 í•„í„°ë§ â†’ 09:00 ëª¨ë‹ˆí„°ë§ ì‹œì‘[/cyan]")
        console.print("[dim]Ctrl+Cë¥¼ ëˆŒëŸ¬ ì¢…ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.[/dim]")
        console.print()

        try:
            while True:
                # ì¼ì¼ ë£¨í‹´ ì‹¤í–‰ (08:50ë¶€í„° 15:30ê¹Œì§€)
                await self.daily_routine()

                # ë£¨í‹´ ì¢…ë£Œ í›„ ë‹¤ìŒë‚ ê¹Œì§€ ëŒ€ê¸°
                console.print()
                console.print("[green]âœ… ì˜¤ëŠ˜ ê±°ë˜ ì¢…ë£Œ[/green]")
                console.print("[cyan]ğŸ’¤ ë‹¤ìŒ ì‚¬ì´í´ì„ ì‹œì‘í•©ë‹ˆë‹¤...[/cyan]")
                console.print()

        except KeyboardInterrupt:
            console.print()
            console.print("[yellow]âš ï¸  ì‚¬ìš©ìê°€ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤.[/yellow]")
        except Exception as e:
            console.print(f"[red]âŒ ì‹œìŠ¤í…œ ì˜¤ë¥˜: {e}[/red]")
            import traceback
            traceback.print_exc()
        finally:
            if self.websocket:
                await self.websocket.close()


async def main():
    """ë©”ì¸ ì‹¤í–‰"""
    console.print()
    console.print("=" * 120, style="bold green")
    console.print(f"{'í‚¤ì›€ ì¡°ê±´ì‹ â†’ VWAP í•„í„°ë§ â†’ ìë™ë§¤ë§¤ í†µí•© ì‹œìŠ¤í…œ':^120}", style="bold green")
    console.print("=" * 120, style="bold green")
    console.print()

    # API í´ë¼ì´ì–¸íŠ¸ ìƒì„±
    console.print("[ì´ˆê¸°í™”] API í´ë¼ì´ì–¸íŠ¸ ìƒì„±")
    api = KiwoomAPI()
    console.print("  âœ“ ì™„ë£Œ")
    console.print()

    # AccessToken ë°œê¸‰
    console.print("[ì´ˆê¸°í™”] AccessToken ë°œê¸‰")
    api.get_access_token()

    if not api.access_token:
        console.print("[red]âŒ í† í° ë°œê¸‰ ì‹¤íŒ¨[/red]")
        return

    console.print("  âœ“ ì™„ë£Œ")
    console.print()

    # ì¡°ê±´ì‹ ì¸ë±ìŠ¤ (ìë™ìœ¼ë¡œ "ì „ëµ" í‚¤ì›Œë“œ í¬í•¨ëœ ì¡°ê±´ì‹ ì„ íƒ)
    CONDITION_INDICES = []  # ë¹ˆ ë¦¬ìŠ¤íŠ¸ë¡œ ì‹œì‘ â†’ get_condition_list()ì—ì„œ ìë™ ì„¤ì •

    # í†µí•© ì‹œìŠ¤í…œ ìƒì„± ë° ì‹¤í–‰
    system = IntegratedTradingSystem(api.access_token, api, CONDITION_INDICES)

    # Ctrl+C í•¸ë“¤ëŸ¬ ë“±ë¡
    def signal_handler(sig, frame):
        console.print()
        console.print("[yellow]âš ï¸  ì¢…ë£Œ ì‹ í˜¸ ìˆ˜ì‹ [/yellow]")
        system.running = False

    signal.signal(signal.SIGINT, signal_handler)

    # ì‹œìŠ¤í…œ ì‹¤í–‰
    await system.run()


if __name__ == "__main__":
    asyncio.run(main())
