"""
í‚¤ì›€ ì¡°ê±´ì‹ â†’ VWAP í•„í„°ë§ â†’ ì‹¤ì‹œê°„ ìë™ë§¤ë§¤ í†µí•© ì‹œìŠ¤í…œ

ì „ì²´ í”Œë¡œìš°:
1. ì¡°ê±´ì‹ 6ê°œë¡œ 1ì°¨ í•„í„°ë§ (50~100ê°œ ì¢…ëª©)
2. VWAP ì‚¬ì „ ê²€ì¦ìœ¼ë¡œ 2ì°¨ í•„í„°ë§ (5~20ê°œ ì¢…ëª©)
3. ì„ ì • ì¢…ëª© ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
4. VWAP ë§¤ìˆ˜ ì‹ í˜¸ ê°ì§€ â†’ ì‚¬ì „ ê²€ì¦ â†’ ìë™ ë§¤ìˆ˜
5. ë³´ìœ  ì¤‘ ëª¨ë‹ˆí„°ë§ â†’ VWAP ë§¤ë„ ì‹ í˜¸ ë˜ëŠ” íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ â†’ ìë™ ë§¤ë„
6. ë¬´í•œ ë£¨í”„ (Ctrl+Cë¡œ ì¤‘ì§€)
"""
import asyncio
import websockets
import json
import sys
import os
import signal
from datetime import datetime, timedelta
from typing import List, Dict, Set, Any, Optional
from pathlib import Path

# í”„ë¡œì íŠ¸ ë£¨íŠ¸ ê²½ë¡œ
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from kiwoom_api import KiwoomAPI
from analyzers.pre_trade_validator import PreTradeValidator
from analyzers.entry_timing_analyzer import EntryTimingAnalyzer
from analyzers.signal_orchestrator import SignalOrchestrator, SignalTier
from utils.config_loader import load_config
from database.trading_db import TradingDatabase
from dotenv import load_dotenv
import yfinance as yf
import pandas as pd
import time
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.live import Live
from rich import box
from trading.exit_logic_optimized import OptimizedExitLogic

# í™˜ê²½ë³€ìˆ˜ ë¡œë“œ
load_dotenv()

# WebSocket URL
SOCKET_URL = 'wss://api.kiwoom.com:10000/api/dostk/websocket'

console = Console()


def download_stock_data_sync(ticker: str, days: int = 7):
    """ì£¼ì‹ ë°ì´í„° ë‹¤ìš´ë¡œë“œ (5ë¶„ë´‰) - ë™ê¸° ë²„ì „"""
    try:
        import warnings
        warnings.filterwarnings('ignore')

        stock = yf.Ticker(ticker)
        df = stock.history(period=f"{days}d", interval="5m")

        if df.empty:
            return None

        df.reset_index(inplace=True)
        df.columns = [col.lower() for col in df.columns]

        # ğŸš¨ ìŒìˆ˜/0 ê°€ê²© í•„í„°ë§ (Yahoo Finance ë²„ê·¸ ëŒ€ì‘)
        if 'close' in df.columns:
            # ìŒìˆ˜ ë˜ëŠ” 0ì¸ í–‰ ì œê±°
            invalid_rows = df[df['close'] <= 0]
            if len(invalid_rows) > 0:
                console.print(f"[yellow]âš ï¸  {ticker}: {len(invalid_rows)}ê°œ ë¹„ì •ìƒ ê°€ê²© ë°ì´í„° ì œê±°[/yellow]")
                df = df[df['close'] > 0].copy()

        # ë°ì´í„°ê°€ ë„ˆë¬´ ì ìœ¼ë©´ None ë°˜í™˜
        if len(df) < 10:
            return None

        return df

    except Exception as e:
        return None


async def download_stock_data_yahoo(ticker: str, days: int = 7, try_kq: bool = True):
    """
    Yahoo Financeì—ì„œ ë°ì´í„° ë‹¤ìš´ë¡œë“œ (ë¹„ë™ê¸°, .KS/.KQ ìë™ ì „í™˜)

    Args:
        ticker: ì¢…ëª© ì½”ë“œ (6ìë¦¬)
        days: ì¡°íšŒ ê¸°ê°„
        try_kq: .KS ì‹¤íŒ¨ ì‹œ .KQ ì‹œë„ ì—¬ë¶€

    Returns:
        DataFrame or None
    """
    # .KS ì‹œë„
    ticker_ks = f"{ticker}.KS"
    try:
        df = await asyncio.to_thread(download_stock_data_sync, ticker_ks, days)
        if df is not None and not df.empty:
            console.print(f"[dim]âœ“ {ticker_ks} ë°ì´í„° ë¡œë“œ ì„±ê³µ ({len(df)}ê°œ ë´‰)[/dim]")
            return df
    except Exception as e:
        console.print(f"[dim]{ticker_ks} ì‹¤íŒ¨: {e}[/dim]")

    # .KQ ì‹œë„
    if try_kq:
        ticker_kq = f"{ticker}.KQ"
        try:
            df = await asyncio.to_thread(download_stock_data_sync, ticker_kq, days)
            if df is not None and not df.empty:
                console.print(f"[dim]âœ“ {ticker_kq} ë°ì´í„° ë¡œë“œ ì„±ê³µ ({len(df)}ê°œ ë´‰)[/dim]")
                return df
        except Exception as e:
            console.print(f"[dim]{ticker_kq} ì‹¤íŒ¨: {e}[/dim]")

    return None


async def get_kiwoom_minute_data(api: KiwoomAPI, stock_code: str, required_bars: int = 100):
    """
    í‚¤ì›€ APIì—ì„œ ë¶„ë´‰ ë°ì´í„° ì¡°íšŒ (5ë¶„ë´‰)
    - ì¤‘ë³µ volume ì»¬ëŸ¼ ìë™ í†µí•© (rename ì‹œ ì¶©ëŒ ë°©ì§€)
    - ì•ˆì •ì ì¸ numeric ë³€í™˜ ë° ì •ë ¬ ì²˜ë¦¬
    """
    try:
        result = api.get_minute_chart(
            stock_code=stock_code,
            tic_scope="5",
            upd_stkpc_tp="1"
        )

        # âœ… 1. ì‘ë‹µ ì½”ë“œ í™•ì¸
        return_code = result.get('return_code')
        if return_code != 0:
            return_msg = result.get('return_msg', 'Unknown error')
            console.print(f"[dim]í‚¤ì›€ API ì˜¤ë¥˜ ({stock_code}): return_code={return_code}, msg={return_msg}[/dim]")
            return None

        # âœ… 2. ì‘ë‹µ ë°ì´í„° í‚¤ íƒìƒ‰
        data = None
        for key in ['stk_min_pole_chart_qry', 'stk_mnut_pole_chart_qry', 'output', 'output1', 'output2', 'data']:
            if key in result and result[key]:
                data = result[key]
                break

        if not data or len(data) == 0:
            console.print(f"[dim]í‚¤ì›€ API ë°ì´í„° ì—†ìŒ ({stock_code})[/dim]")
            return None

        df = pd.DataFrame(data)
        if df.empty:
            console.print(f"[yellow]âš ï¸ ë³€í™˜ëœ DataFrameì´ ë¹„ì–´ ìˆìŒ ({stock_code})[/yellow]")
            return None

        # âœ… 3. cntr_tm â†’ ë‚ ì§œ/ì‹œê°„
        if 'cntr_tm' in df.columns:
            df['datetime'] = df['cntr_tm'].astype(str).str[:8]
            df['time'] = df['cntr_tm'].astype(str).str[8:14]
            df.drop(columns=['cntr_tm'], inplace=True, errors='ignore')

        # âœ… 4. ì•ˆì „í•œ ì»¬ëŸ¼ ë§¤í•‘ (ì¤‘ë³µ ì´ë¦„ ë°©ì§€)
        column_mapping = {
            'dt': 'datetime', 'tm': 'time',
            'stck_bsop_date': 'datetime', 'stck_cntg_hour': 'time',
            'cur_prc': 'close', 'stck_prpr': 'close',
            'open_pric': 'open', 'stck_oprc': 'open',
            'high_pric': 'high', 'stck_hgpr': 'high',
            'low_pric': 'low', 'stck_lwpr': 'low',
            'trde_qty': 'volume1', 'cntg_vol': 'volume2', 'acc_trde_qty': 'volume3'
        }
        df.rename(columns={k: v for k, v in column_mapping.items() if k in df.columns}, inplace=True)

        # âœ… 5. volume í†µí•© (ì—¬ëŸ¬ ì—´ â†’ í‰ê· )
        volume_cols = [c for c in ['volume1', 'volume2', 'volume3'] if c in df.columns]
        if volume_cols:
            df['volume'] = df[volume_cols].apply(pd.to_numeric, errors='coerce').abs().mean(axis=1)
            df.drop(columns=volume_cols, inplace=True, errors='ignore')

        # âœ… 6. ì¤‘ë³µ ì œê±° + ìˆ«ì ë³€í™˜
        df = df.loc[:, ~df.columns.duplicated()]

        # ğŸ”§ CRITICAL: í‚¤ì›€ APIëŠ” ìŒìˆ˜ ë¶€í˜¸ë¡œ í•˜ë½ì„ í‘œì‹œ â†’ ì ˆëŒ€ê°’ ë³€í™˜ í•„ìˆ˜!
        # ì˜ˆ: cur_prc="-78800" â†’ ì‹¤ì œ ê°€ê²©ì€ 78,800ì›
        for col in ['open', 'high', 'low', 'close', 'volume']:
            if col in df.columns:
                df.loc[:, col] = pd.to_numeric(df[col], errors='coerce').abs()

        # âœ… 7. ê²°ì¸¡ì¹˜ ì œê±° ë° ì •ë ¬
        df.dropna(subset=['close'], inplace=True)
        df = df.sort_values(by=['datetime', 'time']).reset_index(drop=True)

        return df

    except Exception as e:
        console.print(f"[yellow]âŒ í‚¤ì›€ API ì¡°íšŒ ì‹¤íŒ¨ ({stock_code}): {e}[/yellow]")
        import traceback
        console.print(f"[dim]{traceback.format_exc()}[/dim]")
        return None


async def validate_stock_for_trading(stock_code: str, stock_name: str, validator: PreTradeValidator, api: KiwoomAPI):
    """
    ì¢…ëª© ì‚¬ì „ ê²€ì¦ (ë§¤ìˆ˜ ì „) - v2 ê°œì„ íŒ

    1. í‚¤ì›€ APIì—ì„œ 5ë¶„ë´‰ ë°ì´í„° ì¡°íšŒ (ìš°ì„ )
    2. ë°ì´í„° ë¶€ì¡± ì‹œ Yahoo Financeë¡œ ë³´ì¶© (.KS/.KQ ìë™ ì „í™˜)
    3. VWAP ê²€ì¦ ì‹¤í–‰
    """
    try:
        required_bars = 100  # í•„ìš”í•œ ìµœì†Œ ë´‰ ê°œìˆ˜
        df = None

        # 1ë‹¨ê³„: í‚¤ì›€ API ì‹œë„
        df = await get_kiwoom_minute_data(api, stock_code, required_bars)

        if df is not None and not df.empty:
            pass  # ì¡°ìš©íˆ ì„±ê³µ
        else:
            console.print(f"  [dim]âœ— í‚¤ì›€: ë°ì´í„° ì—†ìŒ[/dim]")

        # 2ë‹¨ê³„: ë°ì´í„° ë¶€ì¡± ì‹œ Yahooë¡œ ë³´ì¶©
        if df is None or len(df) < required_bars:
            current_bars = len(df) if df is not None else 0
            console.print(f"  [yellow]âš ï¸  ë°ì´í„° ë¶€ì¡± ({current_bars}ê°œ/{required_bars}ê°œ) â†’ Yahoo Finance ë³´ì¶© ì‹œë„[/yellow]")

            yahoo_df = await download_stock_data_yahoo(stock_code, days=7, try_kq=True)

            if yahoo_df is None or yahoo_df.empty:
                console.print(f"  [dim]âœ— ì•¼í›„: ë°ì´í„° ì—†ìŒ[/dim]")
                return {'allowed': False, 'reason': f'ë°ì´í„° ì—†ìŒ (í‚¤ì›€:{current_bars}ê°œ, ì•¼í›„:ì‹¤íŒ¨)'}

            yahoo_bars = len(yahoo_df)
            console.print(f"  [dim]âœ“ ì•¼í›„: {yahoo_bars}ê°œ ë´‰ ìˆ˜ì§‘[/dim]")

            # í‚¤ì›€ ë°ì´í„°ì™€ Yahoo ë°ì´í„° ë³‘í•©
            if df is not None and not df.empty:
                # ê¸°ì¡´ í‚¤ì›€ ë°ì´í„°ì— Yahoo ë°ì´í„°ë¥¼ ì•ì— ì¶”ê°€
                df = pd.concat([yahoo_df, df], ignore_index=True)
                df = df.drop_duplicates(subset=['datetime', 'time'], keep='last').reset_index(drop=True)
                console.print(f"  [green]âœ“ ë³‘í•© ì™„ë£Œ: í‚¤ì›€({current_bars}) + ì•¼í›„({yahoo_bars}) = ì´ {len(df)}ê°œ ë´‰[/green]")
            else:
                df = yahoo_df
                console.print(f"  [cyan]âœ“ ì•¼í›„ ë°ì´í„°ë§Œ ì‚¬ìš©: {len(df)}ê°œ ë´‰[/cyan]")

        # ìµœì¢… ë°ì´í„° ê²€ì¦
        final_bars = len(df) if df is not None else 0

        if df is None or final_bars < required_bars:
            return {'allowed': False, 'reason': f'ë°ì´í„° ë¶€ì¡± ({final_bars}ê°œ < {required_bars}ê°œ)'}

        current_price = df['close'].iloc[-1]
        current_time = datetime.now()

        # VWAP ê²€ì¦ (ì¡°ìš©íˆ ì‹¤í–‰)
        allowed, reason, stats = validator.validate_trade(
            stock_code=stock_code,
            stock_name=stock_name,
            historical_data=df,
            current_price=current_price,
            current_time=current_time
        )

        return {
            'allowed': allowed,
            'reason': reason,
            'stats': stats,
            'data': df
        }

    except Exception as e:
        console.print(f"  [red]âŒ ê²€ì¦ ì˜¤ë¥˜: {e}[/red]")
        import traceback
        console.print(f"  [dim]{traceback.format_exc()}[/dim]")
        return {'allowed': False, 'reason': f'ì˜¤ë¥˜: {str(e)}'}


class IntegratedTradingSystem:
    """í†µí•© ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ"""

    def __init__(self, access_token: str, api: KiwoomAPI, condition_indices: List[int], skip_wait: bool = False):
        self.uri = SOCKET_URL
        self.access_token = access_token
        self.api = api
        self.condition_indices = condition_indices
        self.skip_wait = skip_wait  # ëŒ€ê¸° ì‹œê°„ ê±´ë„ˆë›°ê¸° ì˜µì…˜

        # ì„¤ì • ë¡œë“œ
        self.config = load_config("config/strategy_hybrid.yaml")

        # ìµœì í™”ëœ ì²­ì‚° ë¡œì§ ì´ˆê¸°í™”
        self.exit_logic = OptimizedExitLogic(self.config)

        # SignalOrchestrator ì´ˆê¸°í™” (L0-L6 ì‹œê·¸ë„ íŒŒì´í”„ë¼ì¸)
        self.signal_orchestrator = SignalOrchestrator(
            config=self.config,
            api=self.api
        )
        console.print("[dim]âœ“ SignalOrchestrator ì´ˆê¸°í™” ì™„ë£Œ (L0-L6 íŒŒì´í”„ë¼ì¸)[/dim]")

        # ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”
        self.db = TradingDatabase("data/trading.db")
        console.print("[dim]âœ“ ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì™„ë£Œ[/dim]")

        # VWAP ê²€ì¦ê¸° (ìµœì í™”ëœ ê¸°ì¤€ê°’ ì ìš©)
        self.validator = PreTradeValidator(
            config=self.config,
            lookback_days=10,        # 5 â†’ 10 (í‘œë³¸ í™•ëŒ€)
            min_trades=6,            # 2 â†’ 6 (í†µê³„ì  ìœ ì˜ì„±)
            min_win_rate=40.0,       # 50 â†’ 40 (VWAP ì „ëµ í˜„ì‹¤ ìŠ¹ë¥ )
            min_avg_profit=0.3,      # 0.5 â†’ 0.3 (ì™„í™”)
            min_profit_factor=1.15   # 1.2 â†’ 1.15 (ì™„í™”)
        )

        # VWAP ë¶„ì„ê¸°
        analyzer_config = self.config.get_analyzer_config()
        self.analyzer = EntryTimingAnalyzer(**analyzer_config)

        # WebSocket
        self.websocket = None
        self.connected = False
        self.running = True

        # ì¢…ëª© ê´€ë¦¬
        self.condition_list = []
        self.watchlist: Set[str] = set()  # ëª¨ë‹ˆí„°ë§ ëŒ€ìƒ
        self.validated_stocks: Dict[str, Dict] = {}  # ê²€ì¦ í†µê³¼ ì¢…ëª© ìƒì„¸ ì •ë³´

        # í¬ì§€ì…˜ ê´€ë¦¬
        self.positions: Dict[str, Dict] = {}  # {stock_code: position_info}

        # ì‹¤ì‹œê°„ ë°ì´í„° ìºì‹œ
        self.price_cache: Dict[str, float] = {}

        # ê³„ì¢Œ ì •ë³´ (ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸)
        self.current_cash = 0.0
        self.total_assets = 0.0
        self.positions_value = 0.0

        # ë¦¬ìŠ¤í¬ ê´€ë¦¬ì (ë‚˜ì¤‘ì— ì‹¤ê³„ì¢Œ ê¸°ë°˜ìœ¼ë¡œ ì´ˆê¸°í™”)
        self.risk_manager = None

        # Dry-run ëª¨ë“œ (ë°±í…ŒìŠ¤íŠ¸ ê²€ì¦ìš©)
        self.dry_run_mode = False

    @staticmethod
    def _extract_stock_name(payload: Optional[Any], default: str) -> str:
        """
        ë‹¤ì–‘í•œ í‚¤ì›€ REST ì‘ë‹µ êµ¬ì¡°ì—ì„œ ì¢…ëª©ëª…ì„ ìµœëŒ€í•œ ì¶”ì¶œí•œë‹¤.

        Args:
            payload: API ì‘ë‹µ ê°ì²´ (dict, list, etc.)
            default: ì¶”ì¶œ ì‹¤íŒ¨ ì‹œ ë°˜í™˜í•  ê¸°ë³¸ê°’ (ì¢…ëª©ì½”ë“œ)
        """
        if not payload:
            return default

        candidates: List[Dict[str, Any]] = []

        def add_candidate(value: Any):
            if isinstance(value, dict):
                candidates.append(value)
            elif isinstance(value, list):
                for item in value:
                    if isinstance(item, dict):
                        candidates.append(item)

        add_candidate(payload)
        if isinstance(payload, dict):
            for key in ['output', 'output1', 'output2', 'data', 'result', 'stock_info', 'body']:
                add_candidate(payload.get(key))

        name_keys = [
            'stk_nm', 'hts_kor_isnm', 'stock_name', 'itmsNm', 'hname',
            'prdt_name', 'prdt_abrv_name', 'issue_name', 'kor_name',
            'korSecnNm', 'kor_secn_nm', 'short_name'
        ]

        for candidate in candidates:
            for key in name_keys:
                name = candidate.get(key)
                if isinstance(name, str) and name.strip():
                    return name.strip()

        return default

    def _get_daily_data(self, stock_code: str, market: Optional[str]) -> Optional[pd.DataFrame]:
        """
        ì¼ë´‰ ë°ì´í„° ì¡°íšŒ (ì¼ë´‰ ì¶”ì„¸ í•„í„°ìš©)

        Args:
            stock_code: ì¢…ëª© ì½”ë“œ
            market: ì‹œì¥ êµ¬ë¶„ (KOSPI/KOSDAQ)
        """
        suffix = '.KS' if market == 'KOSPI' else '.KQ'
        ticker = f"{stock_code}{suffix}"

        try:
            history = yf.Ticker(ticker).history(period="90d", interval="1d", auto_adjust=False)
            if history.empty:
                return None

            df = history.reset_index().rename(columns=lambda c: c.lower())
            required_cols = ['open', 'high', 'low', 'close', 'volume']
            if not set(required_cols).issubset(df.columns):
                return None

            return df[required_cols].copy()
        except Exception:
            return None

    async def connect(self):
        """WebSocket ì—°ê²°"""
        try:
            self.websocket = await websockets.connect(self.uri)
            self.connected = True
            console.print("=" * 120, style="bold green")
            console.print(f"{'í‚¤ì›€ í†µí•© ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ':^120}", style="bold green")
            console.print("=" * 120, style="bold green")
            console.print()
        except Exception as e:
            console.print(f"[red]âŒ WebSocket ì—°ê²° ì‹¤íŒ¨: {e}[/red]")
            raise

    async def send_message(self, trnm: str, data: dict = None):
        """WebSocket ë©”ì‹œì§€ ì „ì†¡"""
        if not self.websocket or not self.connected:
            raise Exception("WebSocketì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

        message = {"trnm": trnm}
        if data:
            message.update(data)

        await self.websocket.send(json.dumps(message))

    async def receive_message(self, timeout: float = 10.0):
        """WebSocket ë©”ì‹œì§€ ìˆ˜ì‹  (íƒ€ì„ì•„ì›ƒ ì¶”ê°€)"""
        if not self.websocket or not self.connected:
            raise Exception("WebSocketì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

        try:
            message = await asyncio.wait_for(self.websocket.recv(), timeout=timeout)
            return json.loads(message)
        except asyncio.TimeoutError:
            console.print(f"[yellow]âš ï¸  ì‘ë‹µ ëŒ€ê¸° ì‹œê°„ ì´ˆê³¼ ({timeout}ì´ˆ)[/yellow]")
            return None

    async def login(self):
        """WebSocket ë¡œê·¸ì¸"""
        console.print(f"[{datetime.now().strftime('%H:%M:%S')}] WebSocket ë¡œê·¸ì¸")

        login_packet = {'trnm': 'LOGIN', 'token': self.access_token}
        await self.websocket.send(json.dumps(login_packet))

        response = await self.receive_message()

        if response.get("return_code") == 0:
            console.print("âœ… ë¡œê·¸ì¸ ì„±ê³µ", style="green")
            # ì¸ì¦ ì™„ë£Œ ëŒ€ê¸° (ì¡°ê±´ê²€ìƒ‰ ë“± API í˜¸ì¶œ ì „ì— í•„ìˆ˜!)
            console.print("[yellow]â³ ì„œë²„ ì¸ì¦ ì²˜ë¦¬ ëŒ€ê¸° ì¤‘... (3ì´ˆ)[/yellow]")
            await asyncio.sleep(3.0)
            console.print("[green]âœ… ì¸ì¦ ì™„ë£Œ[/green]")
            console.print()
            return True
        else:
            console.print(f"[red]âŒ ë¡œê·¸ì¸ ì‹¤íŒ¨: {response.get('return_msg')}[/red]")
            return False

    async def initialize_account(self):
        """ê³„ì¢Œ ì •ë³´ ì´ˆê¸°í™” (ì‹œìŠ¤í…œ ì‹œì‘ ì‹œ)"""
        from core.risk_manager import RiskManager

        console.print()
        console.print("=" * 120, style="bold cyan")
        console.print(f"{'ê³„ì¢Œ ì •ë³´ ì¡°íšŒ':^120}", style="bold cyan")
        console.print("=" * 120, style="bold cyan")

        try:
            # 1. ê³„ì¢Œ ì”ê³  ì¡°íšŒ (API-ID: kt00001)
            balance_info = self.api.get_balance()

            # ì˜ˆìˆ˜ê¸ˆ íŒŒì‹± (15ìë¦¬ ë¬¸ìì—´ â†’ ìˆ«ì)
            cash_str = balance_info.get('entr', '000000000000000')
            self.current_cash = float(cash_str)

            # 2. ë³´ìœ  ì¢…ëª© ì¡°íšŒ (API-ID: ka01690)
            account_info = self.api.get_account_info()
            positions = account_info.get('day_bal_rt', [])

            # 3. ë³´ìœ  í¬ì§€ì…˜ í‰ê°€ì•¡ ê³„ì‚°
            self.positions_value = 0.0
            for pos in positions:
                # ë¹ˆ ì¢…ëª©ì€ ìŠ¤í‚µ
                if not pos.get('stk_cd') or pos.get('stk_cd') == '':
                    continue

                cur_prc = int(pos.get('cur_prc', 0)) if pos.get('cur_prc') else 0
                rmnd_qty = int(pos.get('rmnd_qty', 0)) if pos.get('rmnd_qty') else 0
                self.positions_value += cur_prc * rmnd_qty

            # 4. ì´ ìì‚°
            self.total_assets = self.current_cash + self.positions_value

            # 4. ê³„ì¢Œ ì •ë³´ ì¶œë ¥
            table = Table(title="ğŸ’° ê³„ì¢Œ í˜„í™©", box=box.ROUNDED, show_header=True, header_style="bold magenta")
            table.add_column("í•­ëª©", style="cyan", width=20)
            table.add_column("ê¸ˆì•¡", style="yellow", justify="right", width=20)

            table.add_row("ê³„ì¢Œë²ˆí˜¸", self.api.account_number)
            table.add_row("ì˜ˆìˆ˜ê¸ˆ", f"{self.current_cash:,.0f}ì›")
            table.add_row("ë³´ìœ ì¢…ëª© í‰ê°€", f"{self.positions_value:,.0f}ì›")
            table.add_row("ì´ ìì‚°", f"{self.total_assets:,.0f}ì›")
            table.add_row("ë³´ìœ ì¢…ëª© ìˆ˜", f"{len(positions)}ê°œ")

            console.print(table)
            console.print()

            # 5. ë³´ìœ  í¬ì§€ì…˜ ë¡œë“œ
            if positions:
                console.print("[bold]ë³´ìœ  í¬ì§€ì…˜:[/bold]")
                for pos in positions:
                    # ë¹ˆ ì¢…ëª©ì€ ìŠ¤í‚µ
                    stock_code = pos.get('stk_cd', '')
                    if not stock_code or stock_code == '':
                        continue

                    stock_name = pos.get('stk_nm', '')
                    quantity = int(pos.get('rmnd_qty', 0)) if pos.get('rmnd_qty') else 0
                    avg_price = int(pos.get('buy_uv', 0)) if pos.get('buy_uv') else 0
                    current_price = int(pos.get('cur_prc', 0)) if pos.get('cur_prc') else 0
                    profit_rate = float(pos.get('prft_rt', 0)) if pos.get('prft_rt') else 0.0

                    self.positions[stock_code] = {
                        'stock_name': stock_name,
                        'name': stock_name,  # í•˜ìœ„ í˜¸í™˜ì„±
                        'quantity': quantity,
                        'avg_price': avg_price,
                        'entry_price': avg_price,  # í•˜ìœ„ í˜¸í™˜ì„±
                        'current_price': current_price,
                        'profit_rate': profit_rate,
                        'eval_amount': quantity * current_price,
                        'entry_date': datetime.now()  # ë³´ìœ ì¼ ê³„ì‚°ìš© (ì´ˆê¸° ë¡œë“œ ì‹œ)
                    }

                    console.print(f"  â€¢ {stock_name}({stock_code}): {quantity}ì£¼ @ {current_price:,}ì› "
                                f"[{'green' if profit_rate >= 0 else 'red'}]{profit_rate:+.2f}%[/]")
                console.print()

            # 6. ë¦¬ìŠ¤í¬ ê´€ë¦¬ì ì´ˆê¸°í™” (ì‹¤ì œ ì”ê³  ê¸°ë°˜)
            self.risk_manager = RiskManager(
                initial_balance=self.current_cash,
                storage_path='data/risk_log.json'
            )

            console.print(f"[green]âœ“ ë¦¬ìŠ¤í¬ ê´€ë¦¬ì ì´ˆê¸°í™” ì™„ë£Œ (ì´ˆê¸° ì”ê³ : {self.current_cash:,.0f}ì›)[/green]")
            console.print()

        except Exception as e:
            console.print(f"[red]âŒ ê³„ì¢Œ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}[/red]")
            console.print("[yellow]âš ï¸  ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤ (10,000,000ì›)[/yellow]")

            # ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”
            self.current_cash = 10000000
            self.positions_value = 0
            self.total_assets = 10000000

            self.risk_manager = RiskManager(
                initial_balance=self.current_cash,
                storage_path='data/risk_log.json'
            )
            console.print()

    async def update_account_balance(self):
        """ê±°ë˜ í›„ ì‹¤ì‹œê°„ ì”ê³  ì—…ë°ì´íŠ¸"""
        try:
            # 1. ê³„ì¢Œ ì”ê³  ì¡°íšŒ (API-ID: kt00001)
            balance_info = self.api.get_balance()
            cash_str = balance_info.get('entr', str(int(self.current_cash)).zfill(15))
            self.current_cash = float(cash_str)

            # 2. ë³´ìœ  ì¢…ëª© ì¡°íšŒ (API-ID: ka01690)
            account_info = self.api.get_account_info()
            positions = account_info.get('day_bal_rt', [])

            # 3. ë³´ìœ  í¬ì§€ì…˜ í‰ê°€ì•¡ ê³„ì‚°
            self.positions_value = 0.0
            for pos in positions:
                if not pos.get('stk_cd') or pos.get('stk_cd') == '':
                    continue

                cur_prc = int(pos.get('cur_prc', 0)) if pos.get('cur_prc') else 0
                rmnd_qty = int(pos.get('rmnd_qty', 0)) if pos.get('rmnd_qty') else 0
                self.positions_value += cur_prc * rmnd_qty

            # 4. ì´ ìì‚°
            self.total_assets = self.current_cash + self.positions_value

            # 5. ë¦¬ìŠ¤í¬ ê´€ë¦¬ì ì”ê³  ì—…ë°ì´íŠ¸
            if self.risk_manager:
                self.risk_manager.update_balance(self.current_cash)

            console.print(f"[dim]ğŸ’° ì”ê³  ì—…ë°ì´íŠ¸: {self.current_cash:,.0f}ì› (ì´ìì‚°: {self.total_assets:,.0f}ì›)[/dim]")

        except Exception as e:
            console.print(f"[yellow]âš ï¸  ì”ê³  ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}[/yellow]")

    async def get_condition_list(self):
        """ì¡°ê±´ê²€ìƒ‰ì‹ ëª©ë¡ ì¡°íšŒ"""
        console.print("[1] ì¡°ê±´ê²€ìƒ‰ì‹ ëª©ë¡ ì¡°íšŒ")
        console.print()

        await self.send_message("CNSRLST")
        response = await self.receive_message()

        if response.get("return_code") == 0:
            self.condition_list = response.get("data", [])
            console.print(f"âœ… ì´ {len(self.condition_list)}ê°œ ì¡°ê±´ê²€ìƒ‰ì‹ ì¡°íšŒ ì™„ë£Œ", style="green")
            console.print()

            # ì‚¬ìš©í•  ì¡°ê±´ì‹ í‘œì‹œ
            console.print(f"ğŸ¯ ì‚¬ìš© ì¡°ê±´ì‹ ì¸ë±ìŠ¤: {self.condition_indices}", style="bold cyan")
            for idx in self.condition_indices:
                if idx < len(self.condition_list):
                    condition = self.condition_list[idx]
                    seq = condition[0] if len(condition) > 0 else "?"
                    name = condition[1] if len(condition) > 1 else "?"
                    console.print(f"  [{idx}] {name} (seq: {seq})", style="green")
            console.print()

            return True
        else:
            console.print(f"[red]âŒ ì¡°ê±´ê²€ìƒ‰ì‹ ì¡°íšŒ ì‹¤íŒ¨[/red]")
            return False

    async def search_condition(self, seq: str, name: str, retry_count: int = 0, max_retries: int = 2):
        """ì¡°ê±´ê²€ìƒ‰ ì‹¤í–‰"""
        try:
            # ìš”ì²­ ì „ì†¡
            start_time = time.time()
            await self.send_message("CNSRREQ", {
                "seq": seq,
                "search_type": "1",
                "stex_tp": "K"
            })

            # ì‘ë‹µ ìˆ˜ì‹  (íƒ€ì„ì•„ì›ƒ 30ì´ˆ - ì¡°ê±´ê²€ìƒ‰ì€ ì‹œê°„ ì†Œìš”ê°€ ê¸¸ ìˆ˜ ìˆìŒ)
            response = await self.receive_message(timeout=30.0)
            elapsed = time.time() - start_time

            if response is None:
                console.print(f"[yellow]âš ï¸  ì‘ë‹µ ì—†ìŒ (íƒ€ì„ì•„ì›ƒ 30ì´ˆ ì´ˆê³¼, ì´ {elapsed:.1f}ì´ˆ ì†Œìš”)[/yellow]")
                return []

            # ë””ë²„ê¹…: ì‘ë‹µ í™•ì¸
            return_code = response.get('return_code')
            data = response.get('data')

            # ì „ì²´ ì‘ë‹µ êµ¬ì¡° í™•ì¸ (ë””ë²„ê¹…)
            console.print(f"[dim]  ì‘ë‹µ í‚¤: {list(response.keys())}[/dim]")
            console.print(f"[dim]  ì „ì²´ ì‘ë‹µ: {response}[/dim]")
            console.print(f"[dim]  ì‘ë‹µ: {elapsed:.2f}ì´ˆ, return_code={return_code}, data íƒ€ì…={type(data)}, data ê¸¸ì´={len(data) if data else 0}[/dim]")

            # return_codeê°€ Noneì´ê±°ë‚˜ 0ì´ë©´ ì •ìƒ ì²˜ë¦¬
            if return_code is None or return_code == 0:
                stock_list = response.get("data", [])

                # None ì²´í¬
                if stock_list is None:
                    return []

                stock_codes = [s.get("jmcode", "").replace("A", "") for s in stock_list]
                stock_codes = [code for code in stock_codes if code]
                return stock_codes
            else:
                error_msg = response.get('return_msg', 'Unknown')
                console.print(f"[yellow]âš ï¸  ì˜¤ë¥˜: {error_msg} (ì‘ë‹µì‹œê°„: {elapsed:.1f}ì´ˆ)[/yellow]")
                return []
        except websockets.exceptions.ConnectionClosedOK as e:
            if retry_count >= max_retries:
                console.print(f"[red]âŒ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ ({retry_count}/{max_retries}), ê±´ë„ˆëœ€[/red]")
                return []

            console.print(f"[yellow]âš ï¸  WebSocket ì—°ê²° ì¢…ë£Œë¨, ì¬ì—°ê²° ì‹œë„ ({retry_count + 1}/{max_retries})...[/yellow]")
            # ì¬ì—°ê²° ì‹œë„
            try:
                await asyncio.sleep(1.0)  # 1ì´ˆ ëŒ€ê¸° í›„ ì¬ì—°ê²°
                await self.connect()
                # ì¬ì—°ê²° ì„±ê³µ í›„ ë¡œê·¸ì¸ í•„ìˆ˜
                console.print(f"[green]âœ“ ì¬ì—°ê²° ì„±ê³µ, ë¡œê·¸ì¸ ì¤‘...[/green]")
                login_success = await self.login()
                if not login_success:
                    console.print(f"[red]âŒ ì¬ì—°ê²° í›„ ë¡œê·¸ì¸ ì‹¤íŒ¨[/red]")
                    return []
                console.print(f"[green]âœ“ ì¡°ê±´ê²€ìƒ‰ ì¬ì‹œë„: {name}[/green]")
                return await self.search_condition(seq, name, retry_count + 1, max_retries)
            except Exception as reconnect_error:
                console.print(f"[red]âŒ ì¬ì—°ê²° ì‹¤íŒ¨: {reconnect_error}[/red]")
                return []
        except websockets.exceptions.ConnectionClosed as e:
            if retry_count >= max_retries:
                console.print(f"[red]âŒ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ ({retry_count}/{max_retries}), ê±´ë„ˆëœ€[/red]")
                return []

            console.print(f"[red]âŒ WebSocket ì—°ê²° ëŠê¹€, ì¬ì—°ê²° ì‹œë„ ({retry_count + 1}/{max_retries})...[/red]")
            # ì¬ì—°ê²° ì‹œë„
            try:
                await asyncio.sleep(1.0)  # 1ì´ˆ ëŒ€ê¸° í›„ ì¬ì—°ê²°
                await self.connect()
                # ì¬ì—°ê²° ì„±ê³µ í›„ ë¡œê·¸ì¸ í•„ìˆ˜
                console.print(f"[green]âœ“ ì¬ì—°ê²° ì„±ê³µ, ë¡œê·¸ì¸ ì¤‘...[/green]")
                login_success = await self.login()
                if not login_success:
                    console.print(f"[red]âŒ ì¬ì—°ê²° í›„ ë¡œê·¸ì¸ ì‹¤íŒ¨[/red]")
                    return []
                console.print(f"[green]âœ“ ì¡°ê±´ê²€ìƒ‰ ì¬ì‹œë„: {name}[/green]")
                return await self.search_condition(seq, name, retry_count + 1, max_retries)
            except Exception as reconnect_error:
                console.print(f"[red]âŒ ì¬ì—°ê²° ì‹¤íŒ¨: {reconnect_error}[/red]")
                return []
        except Exception as e:
            console.print(f"[red]âŒ ì¡°ê±´ê²€ìƒ‰ ì˜¤ë¥˜: {e}[/red]")
            import traceback
            console.print(f"[dim]{traceback.format_exc()}[/dim]")
            return []

    async def run_condition_filtering(self):
        """1ì°¨ + 2ì°¨ í•„í„°ë§ ì‹¤í–‰"""
        console.print()
        console.print("=" * 120, style="bold cyan")
        console.print(f"{'ì¡°ê±´ê²€ìƒ‰ + VWAP í•„í„°ë§':^120}", style="bold cyan")
        console.print("=" * 120, style="bold cyan")
        console.print()

        try:
            # 1ì°¨ í•„í„°: ì¡°ê±´ê²€ìƒ‰
            console.print("[bold cyan]1ì°¨ í•„í„°: ì¡°ê±´ê²€ìƒ‰ ì‹¤í–‰[/bold cyan]")
            console.print()

            all_stocks = set()
            for idx in self.condition_indices:
                if idx < len(self.condition_list):
                    condition = self.condition_list[idx]
                    seq = condition[0]
                    name = condition[1]

                    console.print(f"[yellow]ì¡°ê±´ì‹ [{idx}] {name} ê²€ìƒ‰ ì¤‘...[/yellow]")
                    stocks = await self.search_condition(seq, name)
                    console.print(f"  âœ… {len(stocks)}ê°œ ì¢…ëª© ë°œê²¬")
                    all_stocks.update(stocks)
                    await asyncio.sleep(0.5)

            console.print()
            console.print(f"[bold green]1ì°¨ í•„í„° í†µê³¼: ì´ {len(all_stocks)}ê°œ ì¢…ëª©[/bold green]")

            if not all_stocks:
                console.print("[yellow]âš ï¸  ì¡°ê±´ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ[/yellow]")
                return

            # L2: RS í•„í„° ì ìš©
            console.print()
            console.print("=" * 120, style="cyan")
            console.print("[bold cyan]L2 í•„í„°: RS (Relative Strength) ìƒëŒ€ê°•ë„ ë¶„ì„[/bold cyan]")
            console.print("=" * 120, style="cyan")
            console.print()

            # ì¢…ëª©ëª… ì¡°íšŒë¥¼ í¬í•¨í•œ candidates ë¦¬ìŠ¤íŠ¸ ìƒì„±
            candidates = []
            for stock_code in all_stocks:
                try:
                    stock_name = stock_code  # ê¸°ë³¸ê°’
                    market = 'KOSPI'  # ê¸°ë³¸ê°’

                    # ì¢…ëª©ëª… ì¡°íšŒ
                    try:
                        result = self.api.get_stock_info(stock_code=stock_code)
                        if result and result.get('return_code') == 0:
                            stock_name = self._extract_stock_name(result, stock_code)
                            # ì‹œì¥ êµ¬ë¶„ (ê°„ë‹¨ ë¡œì§: ì½”ë“œë¡œ íŒë‹¨)
                            market = 'KOSDAQ' if stock_code.startswith(('3', '4', '5', '6', '7')) else 'KOSPI'
                    except Exception:
                        pass

                    candidates.append({
                        'stock_code': stock_code,
                        'stock_name': stock_name,
                        'market': market
                    })
                except Exception:
                    continue

            console.print(f"[dim]RS í•„í„°ë§ ëŒ€ìƒ: {len(candidates)}ê°œ ì¢…ëª©[/dim]")

            # RS í•„í„°ë§
            filtered_candidates = self.signal_orchestrator.check_l2_rs_filter(
                candidates,
                market='KOSPI'  # ê¸°ë³¸ ì‹œì¥ (ê°œë³„ ì¢…ëª©ì€ candidatesì— market í¬í•¨)
            )

            console.print(f"[green]âœ“ RS í•„í„°ë§ ì™„ë£Œ: {len(filtered_candidates)}ê°œ ì¢…ëª© ì„ íƒ (ìƒìœ„ RS ì¢…ëª©)[/green]")
            console.print()

            # í•„í„°ë§ëœ ì¢…ëª©ë§Œ ì²˜ë¦¬
            if not filtered_candidates:
                console.print("[yellow]âš ï¸  RS í•„í„° í†µê³¼ ì¢…ëª© ì—†ìŒ[/yellow]")
                return

            # all_stocksë¥¼ filtered ì¢…ëª©ìœ¼ë¡œ êµì²´
            all_stocks = {c['stock_code'] for c in filtered_candidates}

            # 2ì°¨ í•„í„°: VWAP ê²€ì¦
            console.print()
            console.print("=" * 120, style="yellow")
            console.print("[bold yellow]2ì°¨ í•„í„°: VWAP ë°±í…ŒìŠ¤íŠ¸ ê²€ì¦[/bold yellow]")
            console.print("=" * 120, style="yellow")
            console.print()

            # RS í•„í„°ë§ëœ ì¢…ëª©ì˜ ì •ë³´ë¥¼ dictë¡œ ë³€í™˜ (ë¹ ë¥¸ ì¡°íšŒìš©)
            filtered_dict = {c['stock_code']: c for c in filtered_candidates}

            validated_count = 0
            rejected_count = 0
            for stock_code in all_stocks:
                try:
                    # RS í•„í„°ë§ëœ ì¢…ëª© ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                    candidate_info = filtered_dict.get(stock_code, {})
                    stock_name = candidate_info.get('stock_name', stock_code)
                    market = candidate_info.get('market', 'KOSPI')
                    rs_rating = candidate_info.get('rs_rating', 0)

                    # ì¢…ëª©ëª… ì¬ì¡°íšŒ (RS í•„í„°ì—ì„œ ëª» ê°€ì ¸ì˜¨ ê²½ìš°)
                    if stock_name == stock_code:
                        try:
                            result = self.api.get_stock_info(stock_code=stock_code)
                            if result and result.get('return_code') == 0:
                                stock_name = self._extract_stock_name(result, stock_code)
                        except Exception:
                            pass

                    console.print(f"[dim]ê²€ì¦ ì¤‘: {stock_name} ({stock_code}) - RS {rs_rating:.0f}[/dim]")

                    # í•˜ì´ë¸Œë¦¬ë“œ VWAP ê²€ì¦ (í‚¤ì›€ API + Yahoo Finance)
                    validation_result = await validate_stock_for_trading(
                        stock_code=stock_code,
                        stock_name=stock_name,
                        validator=self.validator,
                        api=self.api
                    )

                    if not validation_result.get('allowed'):
                        rejected_count += 1
                        reason = validation_result.get('reason', 'ì•Œ ìˆ˜ ì—†ìŒ')
                        console.print(f"  [red]âŒ ê±°ë¶€: {reason}[/red]")
                        continue

                    # ê²€ì¦ í†µê³¼
                    validated_count += 1
                    stats = validation_result.get('stats', {})
                    df = validation_result.get('data')

                    self.watchlist.add(stock_code)
                    self.validated_stocks[stock_code] = {
                        'name': stock_name,
                        'market': market,
                        'rs_rating': rs_rating,
                        'stats': stats,
                        'data': df
                    }

                    console.print(
                        f"[green]âœ… {validated_count}. {stock_name} ({stock_code}) - "
                        f"ìŠ¹ë¥  {stats.get('win_rate', 0):.1f}% | "
                        f"í‰ê· ìˆ˜ìµ {stats.get('avg_profit_pct', 0):.2f}% | "
                        f"ê±°ë˜ìˆ˜ {stats.get('total_trades', 0)}[/green]"
                    )

                except Exception as e:
                    rejected_count += 1
                    console.print(f"  [red]âŒ ì˜¤ë¥˜: {str(e)}[/red]")
                    continue

            console.print()
            console.print("=" * 120, style="bold green")
            console.print(f"{'ğŸ“Š í•„í„°ë§ ê²°ê³¼ ìš”ì•½':^120}", style="bold green")
            console.print("=" * 120, style="bold green")
            console.print()
            console.print(f"  1ì°¨ í•„í„° (ì¡°ê±´ê²€ìƒ‰): {len(all_stocks)}ê°œ ì¢…ëª© ë°œê²¬", style="cyan")
            console.print(f"  2ì°¨ í•„í„° (VWAP):     {validated_count}ê°œ ì¢…ëª© ê²€ì¦ í†µê³¼", style="yellow")
            console.print(f"  ìµœì¢… ê°ì‹œ ì¢…ëª©:      {len(self.watchlist)}ê°œ", style="bold green" if len(self.watchlist) > 0 else "bold red")
            console.print()

            # ìµœì¢… ì„ ì • ì¢…ëª© í‘œì‹œ
            if self.watchlist:
                from rich.table import Table
                from rich import box

                table = Table(title="ìµœì¢… ì„ ì • ì¢…ëª© (ëª¨ë‹ˆí„°ë§ ëŒ€ìƒ)", box=box.DOUBLE)
                table.add_column("ìˆœìœ„", style="cyan", justify="right")
                table.add_column("ì¢…ëª©ëª…", style="yellow")
                table.add_column("ì½”ë“œ", style="dim")
                table.add_column("ìŠ¹ë¥ ", justify="right")
                table.add_column("í‰ê· ìˆ˜ìµë¥ ", justify="right", style="green")
                table.add_column("ê±°ë˜ìˆ˜", justify="right")

                sorted_stocks = sorted(
                    self.validated_stocks.items(),
                    key=lambda x: x[1]['stats']['avg_profit_pct'],
                    reverse=True
                )

                for rank, (code, info) in enumerate(sorted_stocks, 1):
                    stats = info['stats']
                    table.add_row(
                        str(rank),
                        info['name'],
                        code,
                        f"{stats['win_rate']:.1f}%",
                        f"{stats['avg_profit_pct']:+.2f}%",
                        f"{stats['total_trades']}íšŒ"
                    )

                console.print(table)
                console.print()

                # 3ì°¨ í•„í„°: ì¢…í•© ë¶„ì„ (ë‰´ìŠ¤ + ê¸°ìˆ  + ìˆ˜ê¸‰ + ê¸°ë³¸)
                console.print("=" * 120, style="magenta")
                console.print(f"{'3ì°¨ í•„í„°: ì¢…í•© ë¶„ì„ (ë‰´ìŠ¤ + ê¸°ìˆ  + ìˆ˜ê¸‰ + ê¸°ë³¸)':^120}", style="bold magenta")
                console.print("=" * 120, style="magenta")
                console.print()

                from analyzers.analysis_engine import AnalysisEngine
                analysis_engine = AnalysisEngine()

                for stock_code, stock_info in list(self.validated_stocks.items()):
                    stock_name = stock_info['name']
                    console.print(f"[cyan]ë¶„ì„ ì¤‘: {stock_name} ({stock_code})[/cyan]")

                    try:
                        # ì°¨íŠ¸ ë°ì´í„° ì¡°íšŒ (ì¼ë´‰ 30ì¼)
                        chart_data = None
                        try:
                            result = self.api.get_ohlcv_data(stock_code, period='D', count=30)
                            if result and result.get("return_code") == 0:
                                chart_data = result.get("data", [])
                                console.print(f"  [dim]âœ“ ì¼ë´‰ {len(chart_data) if chart_data else 0}ê°œ ìˆ˜ì§‘[/dim]")
                        except Exception as e:
                            console.print(f"  [dim]âš ï¸  ì°¨íŠ¸ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨: {e}[/dim]")

                        # ì¢…ëª© ê¸°ë³¸ ì •ë³´ ì¡°íšŒ
                        basic_info = None
                        try:
                            result = self.api.get_stock_info(stock_code)
                            if result and result.get("return_code") == 0:
                                # í‚¤ì›€ API ka10001ì€ ë°ì´í„°ë¥¼ ìµœìƒìœ„ì— ì§ì ‘ ë°˜í™˜
                                basic_info = result
                                console.print(f"  [dim]âœ“ ì¢…ëª© ì •ë³´ ìˆ˜ì§‘ (PER: {result.get('per', 'N/A')}, PBR: {result.get('pbr', 'N/A')})[/dim]")
                        except Exception as e:
                            console.print(f"  [dim]âš ï¸  ì¢…ëª© ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}[/dim]")

                        # íˆ¬ììë³„ ë§¤ë§¤ ë™í–¥ ì¡°íšŒ
                        investor_data = None
                        try:
                            from datetime import datetime as dt
                            today = dt.now().strftime('%Y%m%d')
                            result = self.api.get_investor_trend(stock_code, dt=today)
                            if result and result.get("return_code") == 0:
                                # ka10059 APIëŠ” 'stk_invsr_orgn' í‚¤ì— LIST ë°˜í™˜
                                investor_data = result.get("stk_invsr_orgn", [])
                                console.print(f"  [dim]âœ“ íˆ¬ìì ë™í–¥ {len(investor_data) if investor_data else 0}ê°œ ìˆ˜ì§‘[/dim]")
                        except Exception as e:
                            console.print(f"  [dim]âš ï¸  íˆ¬ìì ë™í–¥ ì¡°íšŒ ì‹¤íŒ¨: {e}[/dim]")

                        # ì¢…í•© ë¶„ì„ ì‹¤í–‰
                        console.print(f"  [dim]ğŸ” AI ì¢…í•© ë¶„ì„ ì‹¤í–‰ ì¤‘...[/dim]")
                        analysis_result = analysis_engine.analyze(
                            stock_code=stock_code,
                            stock_name=stock_name,
                            chart_data=chart_data,
                            investor_data=investor_data,
                            program_data=None,  # í”„ë¡œê·¸ë¨ ë§¤ë§¤ëŠ” ì‹œì¥ ì „ì²´ ë°ì´í„°
                            stock_info=basic_info
                        )

                        # ë¶„ì„ ê²°ê³¼ ì €ì¥
                        stock_info['analysis'] = analysis_result

                        # ë¶„ì„ ê²°ê³¼ ì¶œë ¥
                        final_score = analysis_result.get('final_score', 0)
                        recommendation = analysis_result.get('recommendation', 'ê´€ë§')
                        scores = analysis_result.get('scores_breakdown', {})

                        score_color = "bold green" if final_score >= 70 else "green" if final_score >= 60 else "yellow"
                        console.print(f"  [dim]ğŸ“Š ì¢…í•©ì ìˆ˜: [{score_color}]{final_score:.1f}ì [/{score_color}] | ì¶”ì²œ: {recommendation}[/dim]")
                        console.print(f"  [dim]   ë‰´ìŠ¤: {scores.get('news', 50):.0f} | "
                                     f"ê¸°ìˆ : {scores.get('technical', 50):.0f} | "
                                     f"ìˆ˜ê¸‰: {scores.get('supply_demand', 50):.0f} | "
                                     f"ê¸°ë³¸: {scores.get('fundamental', 50):.0f}[/dim]")
                        console.print()

                    except Exception as e:
                        console.print(f"  [red]âŒ ë¶„ì„ ì˜¤ë¥˜: {e}[/red]")
                        import traceback
                        console.print(f"  [dim]{traceback.format_exc()}[/dim]")
                        continue

                console.print("[green]âœ… ì¢…í•© ë¶„ì„ ì™„ë£Œ[/green]")
                console.print()

        except Exception as e:
            console.print(f"[red]âŒ í•„í„°ë§ ì‹¤í–‰ ì˜¤ë¥˜: {e}[/red]")
            import traceback
            traceback.print_exc()

    async def run_condition_filtering_OLD(self):
        """[DEPRECATED] ê¸°ì¡´ í•„í„°ë§ ë¡œì§ - ì°¸ê³ ìš©"""
        all_stocks = set()
        filter_time = datetime.now()

        for idx in self.condition_indices:
            if idx < len(self.condition_list):
                condition = self.condition_list[idx]
                seq = condition[0]
                name = condition[1]

                console.print(f"  ğŸ” {name} ê²€ìƒ‰ ì¤‘...")
                stocks = await self.search_condition(seq, name)
                all_stocks.update(stocks)
                console.print(f"     â†’ {len(stocks)}ê°œ ë°œê²¬")

                # 1ì°¨ í•„í„°ë§ ê²°ê³¼ DBì— ì €ì¥
                filter_data = {
                    'filter_time': filter_time.isoformat(),
                    'filter_type': '1ì°¨',
                    'condition_name': name,
                    'stocks_found': len(stocks),
                    'stock_codes': list(stocks),
                    'stocks_passed': 0,
                    'stocks_failed': 0,
                    'passed_stocks': [],
                    'schedule_type': 'manual',
                    'is_new_stock': 0
                }
                self.db.insert_filter_history(filter_data)

                await asyncio.sleep(0.5)

        unique_stocks = list(all_stocks)

        console.print()
        console.print(f"ğŸ“Š ì¤‘ë³µ ì œê±° í›„ ì´ {len(unique_stocks)}ê°œ ì¢…ëª©", style="bold green")
        console.print()

        # 2ì°¨ í•„í„°ë§
        console.print("=" * 120, style="bold yellow")
        console.print(f"{'2ë‹¨ê³„: VWAP ì‚¬ì „ ê²€ì¦ (2ì°¨ í•„í„°ë§)':^120}", style="bold yellow")
        console.print("=" * 120, style="bold yellow")
        console.print()

        BATCH_SIZE = 5
        DELAY_BETWEEN_REQUESTS = 0.2
        DELAY_BETWEEN_BATCHES = 1.0

        # ì¢…ëª©ëª… ì¡°íšŒ
        stock_info_list = []
        console.print(f"[cyan]ğŸ“‹ ì¢…ëª©ëª… ì¡°íšŒ ì¤‘... (ì´ {len(unique_stocks)}ê°œ)[/cyan]")

        for i, code in enumerate(unique_stocks, 1):
            try:
                result = self.api.get_stock_info(stock_code=code)
                stock_name = self._extract_stock_name(result, code)

                if stock_name == code:
                    cached_name = self.db.get_recent_stock_name(code)
                    if cached_name:
                        stock_name = cached_name

                if stock_name == code:
                    try:
                        price_result = self.api.get_stock_price(code)
                        stock_name = self._extract_stock_name(price_result, stock_name)
                    except Exception:
                        pass

                if i == 1 and isinstance(result, dict):
                    sample_keys = list(result.keys())[:5]
                    console.print(f"[dim]  DEBUG: {code} APIì‘ë‹µ í‚¤={sample_keys}[/dim]")

                stock_info_list.append((code, stock_name))

                if stock_name != code:
                    if code in self.validated_stocks:
                        self.validated_stocks[code]['name'] = stock_name
                    if code in self.positions:
                        self.positions[code]['name'] = stock_name

                if i % 10 == 0:
                    console.print(f"  {i}/{len(unique_stocks)} ì™„ë£Œ...", style="dim")

                await asyncio.sleep(DELAY_BETWEEN_REQUESTS)

                if i % BATCH_SIZE == 0:
                    await asyncio.sleep(DELAY_BETWEEN_BATCHES)

            except KeyboardInterrupt:
                console.print()
                console.print("[yellow]âš ï¸  ì‚¬ìš©ìê°€ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤. ì§€ê¸ˆê¹Œì§€ ì¡°íšŒí•œ ì¢…ëª©ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤.[/yellow]")
                break
            except Exception as e:
                stock_info_list.append((code, code))
                await asyncio.sleep(DELAY_BETWEEN_REQUESTS)

        console.print(f"[green]âœ… ì¢…ëª©ëª… ì¡°íšŒ ì™„ë£Œ[/green]")
        console.print()

        # VWAP ê²€ì¦
        console.print(f"[cyan]ğŸ” VWAP ê²€ì¦ ì‹œì‘... (í‚¤ì›€ API ìš°ì„ , Yahoo ë³´ì¶©)[/cyan]")
        console.print()

        validated_count = 0
        for i, (code, name) in enumerate(stock_info_list, 1):
            try:
                if i % 5 == 0:
                    console.print(f"  ì§„í–‰: {i}/{len(stock_info_list)}", style="dim")

                result = await validate_stock_for_trading(code, name, self.validator, self.api)

                # DBì— ê²€ì¦ ì ìˆ˜ ì €ì¥
                stats = result.get('stats', {})
                score_data = {
                    'stock_code': code,
                    'stock_name': name,
                    'validation_time': datetime.now().isoformat(),
                    'vwap_win_rate': stats.get('win_rate'),
                    'vwap_avg_profit': stats.get('avg_profit_pct'),
                    'vwap_trade_count': stats.get('total_trades'),
                    'vwap_profit_factor': stats.get('profit_factor'),
                    'vwap_max_profit': stats.get('max_profit_pct'),
                    'vwap_max_loss': stats.get('max_loss_pct'),
                    'news_sentiment_score': None,  # TODO: ë‰´ìŠ¤ ë¶„ì„ ì—°ë™
                    'news_impact_type': None,
                    'news_keywords': [],
                    'news_titles': [],
                    'news_count': 0,
                    'total_score': stats.get('avg_profit_pct', 0),  # ì„ì‹œ: VWAP ì ìˆ˜ë§Œ
                    'weight_vwap': 1.0,  # ì„ì‹œ: VWAPë§Œ ì‚¬ìš©
                    'weight_news': 0.0,
                    'is_passed': 1 if result.get('allowed') else 0
                }
                self.db.insert_validation_score(score_data)

                if result.get('allowed'):
                    self.watchlist.add(code)
                    self.validated_stocks[code] = {
                        'name': name,
                        'stats': stats,
                        'data': result.get('data')
                    }
                    validated_count += 1
                    console.print(
                        f"  âœ… {name}: ìŠ¹ë¥  {stats.get('win_rate', 0):.1f}%, "
                        f"ìˆ˜ìµ {stats.get('avg_profit_pct', 0):+.1f}%",
                        style="green"
                    )

                if i % BATCH_SIZE == 0:
                    await asyncio.sleep(DELAY_BETWEEN_BATCHES)

            except KeyboardInterrupt:
                console.print()
                console.print("[yellow]âš ï¸  ì‚¬ìš©ìê°€ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤. ì§€ê¸ˆê¹Œì§€ ê²€ì¦í•œ ì¢…ëª©ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤.[/yellow]")
                break
            except Exception as e:
                console.print(f"[red]ê²€ì¦ ì˜¤ë¥˜ ({code}): {e}[/red]", style="dim")
                continue

        console.print()
        console.print("=" * 120, style="bold magenta")
        console.print(f"{'ğŸ“Š í•„í„°ë§ ê²°ê³¼ ìš”ì•½':^120}", style="bold magenta")
        console.print("=" * 120, style="bold magenta")
        console.print()
        console.print(f"  1ì°¨ í•„í„°ë§ (ì¡°ê±´ì‹ ê²€ìƒ‰): {len(unique_stocks)}ê°œ ì¢…ëª© ë°œê²¬", style="cyan")
        console.print(f"  2ì°¨ í•„í„°ë§ (VWAP ê²€ì¦): {validated_count}ê°œ í†µê³¼, {len(stock_info_list) - validated_count}ê°œ íƒˆë½", style="yellow")
        console.print(f"  ìµœì¢… ì„ ì • ì¢…ëª©: {validated_count}ê°œ", style="bold green" if validated_count > 0 else "bold red")
        console.print()

        # DEBUG: watchlist ë‚´ìš© í™•ì¸
        console.print(f"[dim]DEBUG: watchlist í¬ê¸° = {len(self.watchlist)}, validated_stocks í¬ê¸° = {len(self.validated_stocks)}[/dim]")

        # ìµœì¢… ì„ ì • ì¢…ëª© í‘œì‹œ
        if self.watchlist:
            table = Table(title="ìµœì¢… ì„ ì • ì¢…ëª© (ëª¨ë‹ˆí„°ë§ ëŒ€ìƒ)", box=box.DOUBLE)
            table.add_column("ìˆœìœ„", style="cyan", justify="right")
            table.add_column("ì¢…ëª©ëª…", style="yellow")
            table.add_column("ì½”ë“œ", style="dim")
            table.add_column("ìŠ¹ë¥ ", justify="right")
            table.add_column("í‰ê· ìˆ˜ìµë¥ ", justify="right", style="green")
            table.add_column("ê±°ë˜ìˆ˜", justify="right")

            sorted_stocks = sorted(
                self.validated_stocks.items(),
                key=lambda x: x[1]['stats']['avg_profit_pct'],
                reverse=True
            )

            for rank, (code, info) in enumerate(sorted_stocks, 1):
                stats = info['stats']
                table.add_row(
                    str(rank),
                    info['name'],
                    code,
                    f"{stats['win_rate']:.1f}%",
                    f"{stats['avg_profit_pct']:+.2f}%",
                    f"{stats['total_trades']}íšŒ"
                )

            console.print(table)
            console.print()

    def is_market_open(self) -> bool:
        """ì¥ ìš´ì˜ ì‹œê°„ ì²´í¬ (í‰ì¼ 09:00 ~ 15:30)"""
        now = datetime.now()

        # ì£¼ë§ ì²´í¬
        if now.weekday() >= 5:  # í† ìš”ì¼(5), ì¼ìš”ì¼(6)
            return False

        # ì¥ ì‹œê°„ ì²´í¬ (09:00 ~ 15:30)
        market_open = now.replace(hour=9, minute=0, second=0, microsecond=0)
        market_close = now.replace(hour=15, minute=30, second=0, microsecond=0)

        return market_open <= now <= market_close

    async def rescan_and_add_stocks(self):
        """ì¡°ê±´ê²€ìƒ‰ ì¬ì‹¤í–‰ ë° ë¦¬ë°¸ëŸ°ì‹± (ìƒˆ ì¢…ëª© ì¶”ê°€ + ì˜¤ë˜ëœ ì¢…ëª© ì œê±°)"""
        try:
            # ê¸°ì¡´ watchlist ë°±ì—…
            original_watchlist = self.watchlist.copy()
            original_validated = self.validated_stocks.copy()

            # ì¡°ê±´ê²€ìƒ‰ + VWAP í•„í„°ë§ ì‹¤í–‰ (ìê¸° ìì‹ ì˜ ë©”ì„œë“œ ì‚¬ìš©)
            # ì£¼ì˜: run_condition_filteringì€ self.watchlistë¥¼ ìƒˆë¡œ ë®ì–´ì”€
            await self.run_condition_filtering()

            # ë¦¬ë°¸ëŸ°ì‹±: ìƒˆ ì¢…ëª© ì¶”ê°€ + ì˜¤ë˜ëœ ì¢…ëª© ì œê±°
            truly_new_stocks = self.watchlist - original_watchlist
            removed_stocks = original_watchlist - self.watchlist

            # ìƒˆë¡œ ì¶”ê°€ëœ ì¢…ëª© í‘œì‹œ
            if truly_new_stocks:
                console.print(f"[cyan]  âœ… ìƒˆë¡œ ë°œê²¬ëœ ì¢…ëª©: {len(truly_new_stocks)}ê°œ[/cyan]")
                for stock_code in truly_new_stocks:
                    stock_info = self.validated_stocks.get(stock_code)
                    if stock_info:
                        console.print(f"[green]     + {stock_info['name']} ({stock_code}) ì¶”ê°€ (ìŠ¹ë¥  {stock_info['stats'].get('win_rate', 0):.1f}%)[/green]")
            else:
                console.print("[dim]  ìƒˆë¡œìš´ ì¢…ëª© ì—†ìŒ[/dim]")

            # ì œê±°ëœ ì¢…ëª© í‘œì‹œ (ì¡°ê±´ ë¯¸ì¶©ì¡±ìœ¼ë¡œ íƒˆë½)
            if removed_stocks:
                console.print(f"[yellow]  ğŸ—‘ï¸  ëª¨ë‹ˆí„°ë§ ì œì™¸ëœ ì¢…ëª©: {len(removed_stocks)}ê°œ[/yellow]")
                for stock_code in removed_stocks:
                    stock_info = original_validated.get(stock_code)
                    stock_name = stock_info['name'] if stock_info else stock_code
                    console.print(f"[dim]     - {stock_name} ({stock_code}) ì œê±° (ì¡°ê±´ ë¯¸ì¶©ì¡±)[/dim]")

            # ìš”ì•½
            console.print(f"[cyan]  ğŸ“Š ë¦¬ë°¸ëŸ°ì‹± ì™„ë£Œ: ì´ {len(self.watchlist)}ê°œ ì¢…ëª© ëª¨ë‹ˆí„°ë§ ì¤‘[/cyan]")

        except Exception as e:
            console.print(f"[yellow]âš ï¸  ì¬ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜: {e}[/yellow]")
            import traceback
            traceback.print_exc()

    async def monitor_and_trade(self):
        """ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ë° ë§¤ë§¤ (5ë¶„ë§ˆë‹¤ ì¡°ê±´ê²€ìƒ‰ ì¬ì‹¤í–‰)"""
        console.print("=" * 120, style="bold magenta")
        console.print(f"{'3ë‹¨ê³„: ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘':^120}", style="bold magenta")
        console.print("=" * 120, style="bold magenta")
        console.print()

        console.print(f"ğŸ¯ ì´ˆê¸° ëª¨ë‹ˆí„°ë§ ëŒ€ìƒ: {len(self.watchlist)}ê°œ ì¢…ëª©")
        console.print(f"â° ì‹œì‘ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        console.print(f"ğŸ”„ 5ë¶„ë§ˆë‹¤ ì¡°ê±´ê²€ìƒ‰ ì¬ì‹¤í–‰ â†’ ìƒˆ ì¢…ëª© ìë™ ì¶”ê°€")

        if len(self.watchlist) == 0:
            console.print()
            console.print("[yellow]âš ï¸  ê°ì‹œ ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤![/yellow]")
            console.print("[yellow]   - Menu [2]ì—ì„œ ì¡°ê±´ê²€ìƒ‰ í•„í„°ë§ì„ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”.[/yellow]")
            console.print("[yellow]   - ë˜ëŠ” ì¥ ì‹œì‘ í›„ ìë™ìœ¼ë¡œ ì¡°ê±´ê²€ìƒ‰ì´ ì‹¤í–‰ë©ë‹ˆë‹¤.[/yellow]")

        console.print()

        # ì´ˆê¸° ì¢…ëª© í…Œì´ë¸” í‘œì‹œ (ì¥ ì‹œê°„ ì—¬ë¶€ ë¬´ê´€)
        await self.check_all_stocks()
        console.print()

        # ì¥ ì‹œê°„ ì²´í¬
        if not self.is_market_open():
            console.print("[yellow]âš ï¸  í˜„ì¬ ì¥ ìš´ì˜ ì‹œê°„ì´ ì•„ë‹™ë‹ˆë‹¤.[/yellow]")
            console.print("[yellow]   í‰ì¼ 09:00 ~ 15:30ì—ë§Œ ëª¨ë‹ˆí„°ë§ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.[/yellow]")
            console.print()
            console.print("[cyan]ğŸ’¡ ì¥ ì‹œì‘ ì‹œê°„ê¹Œì§€ ëŒ€ê¸°í•©ë‹ˆë‹¤...[/cyan]")
            console.print("[dim]Ctrl+Cë¥¼ ëˆŒëŸ¬ ì¢…ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.[/dim]")
            console.print()
        else:
            console.print("[cyan]âœ… ì¥ì´ ì—´ë ¤ìˆìŠµë‹ˆë‹¤. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘...[/cyan]")
            console.print("[dim]Ctrl+Cë¥¼ ëˆŒëŸ¬ ì¢…ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.[/dim]")
            console.print()

        check_interval = 60  # 1ë¶„ë§ˆë‹¤ ì¢…ëª© ì²´í¬
        rescan_interval = 300  # 5ë¶„ë§ˆë‹¤ ì¡°ê±´ê²€ìƒ‰ ì¬ì‹¤í–‰

        last_check = datetime.now()
        last_rescan = datetime.now()
        last_status_update = datetime.now()

        try:
            while self.running:
                current_time = datetime.now()

                # ì¥ ì‹œê°„ì¸ì§€ ì²´í¬
                if self.is_market_open():
                    # 5ë¶„ë§ˆë‹¤ ì¡°ê±´ê²€ìƒ‰ ì¬ì‹¤í–‰
                    if (current_time - last_rescan).seconds >= rescan_interval:
                        console.print()
                        console.print("[cyan]ğŸ”„ 5ë¶„ ê²½ê³¼ - ì¡°ê±´ê²€ìƒ‰ ì¬ì‹¤í–‰ ì¤‘...[/cyan]")
                        await self.rescan_and_add_stocks()
                        last_rescan = current_time
                        console.print(f"[green]âœ… í˜„ì¬ ëª¨ë‹ˆí„°ë§ ì¢…ëª©: {len(self.watchlist)}ê°œ[/green]")
                        console.print()

                    # 1ë¶„ë§ˆë‹¤ ì¢…ëª© ì²´í¬
                    elif (current_time - last_check).seconds >= check_interval:
                        await self.check_all_stocks()
                        last_check = current_time
                    else:
                        # ë‚¨ì€ ì‹œê°„ ì¹´ìš´íŠ¸ë‹¤ìš´ (ê°™ì€ ì¤„ì—ì„œ ê°±ì‹ )
                        elapsed = (current_time - last_check).seconds
                        remaining = check_interval - elapsed

                        # ë‹¤ìŒ ì¬ê²€ìƒ‰ê¹Œì§€ ë‚¨ì€ ì‹œê°„ë„ í‘œì‹œ
                        rescan_elapsed = (current_time - last_rescan).seconds
                        rescan_remaining = rescan_interval - rescan_elapsed
                        rescan_min = rescan_remaining // 60
                        rescan_sec = rescan_remaining % 60

                        import sys
                        sys.stdout.write(f"\rë‹¤ìŒ ì²´í¬: {remaining}ì´ˆ í›„ | ë‹¤ìŒ ì¬ê²€ìƒ‰: {rescan_min}ë¶„ {rescan_sec}ì´ˆ í›„ | Ctrl+C: ì¢…ë£Œ   ")
                        sys.stdout.flush()
                else:
                    # ì¥ ì‹œê°„ì´ ì•„ë‹ˆë©´ ìƒíƒœ ì—…ë°ì´íŠ¸ (5ì´ˆë§ˆë‹¤ë§Œ ê°±ì‹ í•˜ì—¬ ëœ intrusiveí•˜ê²Œ)
                    if (current_time - last_status_update).seconds >= 5:
                        import sys
                        sys.stdout.write(f"\rğŸ’¤ ì¥ì¤‘ ì•„ë‹˜ | ëŒ€ê¸° ì¤‘... ({current_time.strftime('%H:%M:%S')})   ")
                        sys.stdout.flush()
                        last_status_update = current_time

                # asyncio.sleep ì‚¬ìš© (KeyboardInterrupt ê°ì§€ ê°€ëŠ¥)
                await asyncio.sleep(1)

        except KeyboardInterrupt:
            print()  # ì¤„ë°”ê¿ˆìœ¼ë¡œ ^C ë‹¤ìŒ ì¤„ë¡œ ì´ë™
            self.shutdown()
            return  # ì¦‰ì‹œ ì¢…ë£Œ

    async def check_all_stocks(self):
        """ëª¨ë“  ì¢…ëª© ì²´í¬ ë° ì‹¤ì‹œê°„ í…Œì´ë¸” ê°±ì‹  (ë§¤ìˆ˜ ì¡°ê±´ + ë³´ìœ  ì¢…ëª© í¬í•¨)"""
        import sys
        import os
        from rich.table import Table
        from rich.live import Live
        from datetime import datetime
        import logging

        # ì—ëŸ¬ ë¡œê·¸ë¥¼ íŒŒì¼ì— ì €ì¥
        error_logger = logging.getLogger('error_logger')
        if not error_logger.handlers:
            fh = logging.FileHandler('/home/greatbps/projects/kiwoom_trading/logs/auto_trading_errors.log')
            fh.setLevel(logging.ERROR)
            formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
            fh.setFormatter(formatter)
            error_logger.addHandler(fh)
            error_logger.setLevel(logging.ERROR)

        current_time = datetime.now().strftime('%H:%M:%S')

        # ì¢…ëª©ë³„ ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì§‘
        stock_data = []

        # ëª¨ë‹ˆí„°ë§ ëŒ€ìƒ: watchlist + ë³´ìœ  ì¢…ëª© (ì¤‘ë³µ ì œê±°)
        all_stocks = set(self.watchlist) | set(self.positions.keys())

        for stock_code in all_stocks:
            try:
                # watchlist ì¢…ëª©ì€ validated_stocksì—ì„œ, ë³´ìœ  ì¢…ëª©ì€ positionsì—ì„œ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                if stock_code in self.validated_stocks:
                    stock_info = self.validated_stocks[stock_code]
                    stock_name = stock_info['name']

                    # ì¢…ëª©ëª…ì´ ì½”ë“œì™€ ê°™ìœ¼ë©´ (ì¡°íšŒ ì‹¤íŒ¨) ë‹¤ì‹œ ì¡°íšŒ
                    if stock_name == stock_code:
                        try:
                            result = self.api.get_stock_info(stock_code=stock_code)
                            if result and result.get('return_code') == 0:
                                stock_name = self._extract_stock_name(result, stock_code)
                                # validated_stocks ì—…ë°ì´íŠ¸
                                stock_info['name'] = stock_name
                        except Exception:
                            pass  # ì‹¤íŒ¨í•´ë„ ì½”ë“œë¡œ í‘œì‹œ

                elif stock_code in self.positions:
                    # ë³´ìœ  ì¢…ëª©ì¸ ê²½ìš°
                    stock_info = None
                    stock_name = self.positions[stock_code].get('name', stock_code)

                    # ì¢…ëª©ëª…ì´ ì½”ë“œì™€ ê°™ìœ¼ë©´ (ì¡°íšŒ ì‹¤íŒ¨) ë‹¤ì‹œ ì¡°íšŒ
                    if stock_name == stock_code:
                        try:
                            result = self.api.get_stock_info(stock_code=stock_code)
                            if result and result.get('return_code') == 0:
                                stock_name = self._extract_stock_name(result, stock_code)
                                # positions ì—…ë°ì´íŠ¸
                                self.positions[stock_code]['name'] = stock_name
                        except Exception:
                            pass  # ì‹¤íŒ¨í•´ë„ ì½”ë“œë¡œ í‘œì‹œ
                else:
                    console.print(f"[dim]âš ï¸  {stock_code}: ì •ë³´ ì—†ìŒ[/dim]")
                    continue

                # 1ì°¨: í‚¤ì›€ APIì—ì„œ 5ë¶„ë´‰ ë°ì´í„° ì¡°íšŒ (ìµœê·¼ 900ê°œ)
                current_hour = datetime.now().hour
                current_minute = datetime.now().minute

                df = None
                kiwoom_bars = 0
                realtime_price = None  # ì‹¤ì‹œê°„ í˜„ì¬ê°€

                # ëª¨ë“  ì¢…ëª©ì˜ ì‹¤ì‹œê°„ í˜„ì¬ê°€ ìš°ì„  ì¡°íšŒ (ì¥ì¤‘ì—ë§Œ)
                if 9 <= current_hour < 16:
                    try:
                        # ì¥ë§ˆê° ì‹œê°„(15:30) ì²´í¬
                        is_market_open = not (current_hour == 15 and current_minute >= 30)

                        if is_market_open:
                            price_result = self.api.get_stock_price(stock_code)
                            if price_result and price_result.get('return_code') == 0:
                                output = price_result.get('output') or price_result.get('output1')
                                if output:
                                    # í˜„ì¬ê°€ ì¶”ì¶œ (ì—¬ëŸ¬ í‚¤ ì‹œë„)
                                    for key in ['stck_prpr', 'cur_prc', 'price', 'current_price']:
                                        if key in output:
                                            realtime_price = float(output[key])
                                            console.print(f"[dim]  âœ“ {stock_code}: ì‹¤ì‹œê°„ í˜„ì¬ê°€ {realtime_price:,.0f}ì›[/dim]")
                                            break
                    except Exception as e:
                        # API ì‹¤íŒ¨ëŠ” ì •ìƒ ë™ì‘ (5ë¶„ë´‰ ë°ì´í„° ì‚¬ìš©)
                        pass

                # ì¥ì¤‘(9:00~15:30)ì—ë§Œ 5ë¶„ë´‰ í‚¤ì›€ API í˜¸ì¶œ
                if 9 <= current_hour < 16:
                    try:
                        result = self.api.get_minute_chart(
                            stock_code=stock_code,
                            tic_scope="5",
                            upd_stkpc_tp="1"
                        )

                        if result.get('return_code') == 0:
                            # ì‘ë‹µ ë°ì´í„° í‚¤ íƒìƒ‰
                            data = None
                            for key in ['stk_min_pole_chart_qry', 'stk_mnut_pole_chart_qry', 'output', 'output1', 'output2', 'data']:
                                if key in result and result[key]:
                                    data = result[key]
                                    break

                            if data and len(data) > 0:
                                import pandas as pd
                                df = pd.DataFrame(data)

                                # ë””ë²„ê¹…: ì‹¤ì œ ì»¬ëŸ¼ ì¶œë ¥
                                console.print(f"[dim]  í‚¤ì›€ API ì»¬ëŸ¼: {list(df.columns)}[/dim]")

                                # ì»¬ëŸ¼ ë§¤í•‘ (ka10080 API ê¸°ì¤€)
                                column_mapping = {
                                    'cur_prc': 'close',      # í˜„ì¬ê°€
                                    'open_pric': 'open',     # ì‹œê°€
                                    'high_pric': 'high',     # ê³ ê°€
                                    'low_pric': 'low',       # ì €ê°€
                                    'trde_qty': 'volume',    # ê±°ë˜ëŸ‰
                                    # ë‹¤ë¥¸ API í˜¸í™˜ì„±
                                    'stck_prpr': 'close', 'cur_price': 'close',
                                    'stck_oprc': 'open', 'open_price': 'open',
                                    'stck_hgpr': 'high', 'high_price': 'high',
                                    'stck_lwpr': 'low', 'low_price': 'low',
                                    'cntg_vol': 'volume', 'acml_vol': 'volume', 'vol': 'volume',
                                    'acml_tr_pbmn': 'volume'
                                }
                                df.rename(columns={k: v for k, v in column_mapping.items() if k in df.columns}, inplace=True)

                                # ğŸ”§ CRITICAL: í‚¤ì›€ APIëŠ” ìŒìˆ˜ ë¶€í˜¸ë¡œ í•˜ë½ì„ í‘œì‹œ â†’ ì ˆëŒ€ê°’ ë³€í™˜ í•„ìˆ˜!
                                # ì˜ˆ: cur_prc="-78800" â†’ ì‹¤ì œ ê°€ê²©ì€ 78,800ì›
                                for col in ['open', 'high', 'low', 'close', 'volume']:
                                    if col in df.columns:
                                        # ë¬¸ìì—´ â†’ ìˆ«ì ë³€í™˜ í›„ ì ˆëŒ€ê°’ ì ìš©
                                        df[col] = pd.to_numeric(df[col], errors='coerce').abs()

                                # volume ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì¶”ê°€
                                if 'volume' not in df.columns:
                                    console.print(f"[yellow]  âš ï¸  {stock_code}: volume ì»¬ëŸ¼ ì—†ìŒ, ê¸°ë³¸ê°’ ì‚¬ìš©[/yellow]")
                                    df['volume'] = 1000  # ê¸°ë³¸ ê±°ë˜ëŸ‰

                                # ì‹œê°„ ì •ë ¬: cntr_tmìœ¼ë¡œ ì •ë ¬ (ìµœì‹  ë°ì´í„°ê°€ ë§ˆì§€ë§‰ì— ì˜¤ë„ë¡)
                                if 'cntr_tm' in df.columns:
                                    df['cntr_tm'] = pd.to_numeric(df['cntr_tm'], errors='coerce')
                                    df = df.sort_values('cntr_tm', ascending=True).reset_index(drop=True)
                                    console.print(f"[dim]  âœ“ {stock_code}: í‚¤ì›€ {len(df)}ê°œ ë´‰ (ì‹œê°„ ì •ë ¬ ì™„ë£Œ, ìµœì‹ : {df['cntr_tm'].iloc[-1]})[/dim]")
                                else:
                                    console.print(f"[dim]  âœ“ {stock_code}: í‚¤ì›€ {len(df)}ê°œ ë´‰[/dim]")

                                kiwoom_bars = len(df)
                    except Exception as e:
                        console.print(f"[dim]  âš ï¸  {stock_code}: í‚¤ì›€ API ì˜¤ë¥˜ - {e}[/dim]")

                # 2ì°¨: ë°ì´í„° ë¶€ì¡± ì‹œ Yahoo Financeë¡œ ë³´ì¶©
                if df is None or len(df) < 20:
                    # ì‹œì¥ ì •ë³´ í™•ì¸ (Yahoo Finance Tickerìš©)
                    market = None
                    if stock_code in self.validated_stocks:
                        market = self.validated_stocks[stock_code].get('market', None)

                    if not market:
                        market = 'KOSPI' if stock_code.startswith('0') else 'KOSDAQ'

                    ticker_suffix = '.KS' if market == 'KOSPI' else '.KQ'
                    ticker = f"{stock_code}{ticker_suffix}"

                    # ë¶€ì¡±í•œ ë§Œí¼ Yahooì—ì„œ ê°€ì ¸ì˜¤ê¸°
                    needed = 20 - (len(df) if df is not None else 0)
                    days_needed = max(1, (needed // 70) + 1)  # 5ë¶„ë´‰: í•˜ë£¨ ì•½ 70ê°œ

                    yahoo_df = download_stock_data_sync(ticker, days=days_needed)

                    if yahoo_df is not None and len(yahoo_df) > 0:
                        if df is not None:
                            # í‚¤ì›€ + ì•¼í›„ ê²°í•©
                            df = pd.concat([yahoo_df, df], ignore_index=True).drop_duplicates()
                            console.print(f"[dim]  âœ“ {stock_code}: í‚¤ì›€ {kiwoom_bars}ê°œ + ì•¼í›„ {len(yahoo_df)}ê°œ = ì´ {len(df)}ê°œ[/dim]")
                        else:
                            df = yahoo_df
                            console.print(f"[dim]  âœ“ {stock_code}: ì•¼í›„ {len(df)}ê°œ ë´‰[/dim]")

                if df is None or len(df) < 20:
                    # ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨ ì‹œ fallback: DB ì •ë³´ë¡œ ê¸°ë³¸ í‘œì‹œ
                    console.print(f"[yellow]âš ï¸  {stock_code}: ì‹¤ì‹œê°„ ë°ì´í„° ì—†ìŒ, DB ì •ë³´ë¡œ í‘œì‹œ[/yellow]")

                    # DB ì •ë³´ë¡œ ê¸°ë³¸ ë°ì´í„° ìƒì„±
                    stock_data.append({
                        'code': stock_code,
                        'name': stock_name,
                        'holding': "ğŸ”µ ë³´ìœ " if stock_code in self.positions else "",
                        'price': 0,  # ì‹¤ì‹œê°„ ê°€ê²© ì—†ìŒ
                        'vwap': 0,
                        'vwap_ok': False,
                        'ma20': 0,
                        'ma20_ok': False,
                        'volume_change_pct': 0,
                        'volume_ok': False,
                        'z_score': 0,
                        'short_term_surge': False,
                        'statistical_spike': False,
                        'trade_value_surge': False,
                        'volume_signals_met': 0,
                        'signal': "â“ ë°ì´í„° ì—†ìŒ",
                        'signal_color': "dim",
                        'conditions_met': 0,
                        'time': current_time
                    })
                    continue

                # VWAP ì„¤ì • ê°€ì ¸ì˜¤ê¸°
                vwap_config = self.config.get_section('vwap')
                use_rolling = vwap_config.get('use_rolling', True)
                rolling_window = vwap_config.get('rolling_window', 20)

                # VWAP, MA20, ATR ê³„ì‚°
                df = self.analyzer.calculate_vwap(df, use_rolling=use_rolling, rolling_window=rolling_window)
                df['ma20'] = df['close'].rolling(window=20).mean()
                df['volume_ma5'] = df['volume'].rolling(window=5).mean()
                df['volume_ma20'] = df['volume'].rolling(window=20).mean()
                df['trade_value'] = df['close'] * df['volume']  # ê±°ë˜ëŒ€ê¸ˆ

                # ë³´ìœ  ì¢…ëª©ì˜ ê²½ìš° ì‹¤ì‹œê°„ ê°€ê²© ìš°ì„  ì‚¬ìš©
                if realtime_price is not None:
                    current_price = realtime_price
                else:
                    current_price = df['close'].iloc[-1]

                # ê°€ê²© ê²€ì¦: 0 ë˜ëŠ” ìŒìˆ˜ë©´ ì—ëŸ¬ ë¡œê·¸
                if current_price <= 0:
                    error_msg = f"{stock_code}: ë¹„ì •ìƒ í˜„ì¬ê°€ {current_price} (realtime={realtime_price}, df_close={df['close'].iloc[-1]})"
                    error_logger.error(error_msg)
                    console.print(f"[yellow]âš ï¸  {error_msg}[/yellow]")
                    continue

                current_vwap = df['vwap'].iloc[-1]
                current_ma20 = df['ma20'].iloc[-1]
                current_volume = df['volume'].iloc[-1]

                # ========================================
                # Eì•ˆ: ë‹¤ë‹¨ê³„ ê°€ì¤‘ ê¸°ë°˜ ê±°ë˜ëŸ‰ ê¸‰ë“± íƒì§€
                # ========================================

                # 1. ë‹¨ê¸° í­ë°œ íƒì§€ (ì§ì „ 25ë¶„ ëŒ€ë¹„)
                recent_avg = df['volume'].iloc[-6:-1].mean() if len(df) >= 6 else df['volume'].mean()
                short_term_surge = (current_volume / recent_avg) > 1.8 if recent_avg > 0 else False

                # 2. í†µê³„ì  ì´ìƒì¹˜ íƒì§€ (Z-score)
                volume_mean = df['volume'].iloc[-20:].mean() if len(df) >= 20 else df['volume'].mean()
                volume_std = df['volume'].iloc[-20:].std() if len(df) >= 20 else 1
                z_score = (current_volume - volume_mean) / volume_std if volume_std > 0 else 0
                statistical_spike = z_score > 1.8

                # 3. ê±°ë˜ëŒ€ê¸ˆ ê°•í™” í•„í„°
                trade_value_ma20 = df['trade_value'].rolling(window=20).mean().iloc[-1] if len(df) >= 20 else df['trade_value'].mean()
                current_trade_value = df['trade_value'].iloc[-1]
                trade_value_surge = (current_trade_value / trade_value_ma20) > 1.5 if trade_value_ma20 > 0 else False

                # 4. ì‹œê°„ëŒ€ ë³´ì •
                current_hour = datetime.now().hour
                if 9 <= current_hour < 10:
                    volume_threshold = 2.0  # ì¥ì´ˆë°˜ ê¸°ì¤€ ê°•í™”
                elif 14 <= current_hour < 15:
                    volume_threshold = 1.3  # ì¥ë§ˆê° ê¸°ì¤€ ì™„í™”
                else:
                    volume_threshold = 1.5

                # 5. ìµœì¢… ê±°ë˜ëŸ‰ ì¡°ê±´ (2ê°œ ì´ìƒ ì¶©ì¡±)
                volume_signals = [short_term_surge, statistical_spike, trade_value_surge]
                volume_signals_met = sum(volume_signals)
                condition_volume = volume_signals_met >= 2

                # ê¸°ì¡´ volume_change_pctë„ ìœ ì§€ (í‘œì‹œìš©)
                volume_ma20 = df['volume_ma20'].iloc[-1] if len(df) >= 20 else df['volume'].mean()
                if volume_ma20 > 0:
                    volume_change_pct = ((current_volume - volume_ma20) / volume_ma20 * 100)
                    # ê±°ë˜ëŸ‰ ë¹„ìœ¨ì´ -95% ë¯¸ë§Œì´ë©´ (ê±°ì˜ ê±°ë˜ ì—†ìŒ) 0ìœ¼ë¡œ í‘œì‹œ
                    if volume_change_pct < -95:
                        volume_change_pct = 0.0
                else:
                    volume_change_pct = 0.0

                # ë§¤ìˆ˜ ì¡°ê±´ ì²´í¬
                condition_vwap = current_price > current_vwap  # VWAP ìœ„
                condition_ma20 = current_price > current_ma20  # MA20 ìœ„ (ìƒìŠ¹ì¶”ì„¸)

                # ì‹œê·¸ë„ íŒë‹¨
                conditions_met = sum([condition_vwap, condition_ma20, condition_volume])

                if conditions_met == 3:
                    signal = "âœ… ë§¤ìˆ˜"
                    signal_color = "green"
                elif conditions_met >= 2:
                    signal = "â³ ëŒ€ê¸°"
                    signal_color = "yellow"
                else:
                    signal = "âŒ ì œì™¸"
                    signal_color = "red"

                # ë³´ìœ  ì—¬ë¶€ í‘œì‹œ
                holding_status = "ğŸ”µ ë³´ìœ " if stock_code in self.positions else ""

                stock_data.append({
                    'code': stock_code,
                    'name': stock_name,
                    'holding': holding_status,
                    'price': current_price,
                    'vwap': current_vwap,
                    'vwap_ok': condition_vwap,
                    'ma20': current_ma20,
                    'ma20_ok': condition_ma20,
                    'volume_change_pct': volume_change_pct,
                    'volume_ok': condition_volume,
                    # ê±°ë˜ëŸ‰ ìƒì„¸ ë¶„ì„ (Eì•ˆ)
                    'z_score': z_score,
                    'short_term_surge': short_term_surge,
                    'statistical_spike': statistical_spike,
                    'trade_value_surge': trade_value_surge,
                    'volume_signals_met': volume_signals_met,
                    'signal': signal,
                    'signal_color': signal_color,
                    'conditions_met': conditions_met,
                    'time': current_time,
                    'historical_df': df  # ë°±í…ŒìŠ¤íŠ¸ìš© íˆìŠ¤í† ë¦¬ ë°ì´í„° ì¶”ê°€
                })

                # ë§¤ìˆ˜/ë§¤ë„ ì‹ í˜¸ ì²´í¬ (ê¸°ì¡´ ë¡œì§)
                if stock_code in self.positions:
                    self.check_exit_signal(stock_code, df)  # historical_df ì „ë‹¬
                else:
                    await self.check_entry_signal(stock_code, df)  # í‚¤ì›€ ë°ì´í„° ì „ë‹¬ (async)

            except Exception as e:
                import traceback
                error_msg = f"âŒ {stock_code}: {e}\n{traceback.format_exc()}"

                # íŒŒì¼ì— ë¡œê·¸ ì €ì¥
                error_logger.error(error_msg)

                # í™”ë©´ì—ëŠ” ê°„ë‹¨íˆë§Œ í‘œì‹œ
                console.print(f"[red]âŒ {stock_code}: {e} (ìƒì„¸ ë¡œê·¸: logs/auto_trading_errors.log)[/red]")
                continue

        # ì¡°ê±´ ì¶©ì¡± ê°œìˆ˜ ìˆœ â†’ ë§¤ìˆ˜ ì‹œê·¸ë„ ìš°ì„ 
        stock_data.sort(key=lambda x: x['conditions_met'], reverse=True)

        # ë³´ìœ  ì¢…ëª©ì˜ AI ì ìˆ˜ì™€ ìŠ¹ë¥ ì„ ìºì‹± (ì‹œë®¬ë ˆì´ì…˜ í…Œì´ë¸”ì—ì„œ ì¬ì‚¬ìš©)
        position_scores = {}  # {stock_code: {'ai_score': 0, 'win_rate': 0}}

        # ========================================
        # 0. ë³´ìœ  í¬ì§€ì…˜ ìƒì„¸ í…Œì´ë¸” (ìµœìš°ì„  í‘œì‹œ)
        # ========================================
        # í™”ë©´ í´ë¦¬ì–´ (ê¸°ì¡´ í…Œì´ë¸” ì§€ìš°ê³  ì—…ë°ì´íŠ¸)
        os.system('clear' if os.name == 'posix' else 'cls')
        console.print()

        if len(self.positions) > 0:
            holdings_table = Table(
                title=f"ğŸ“Š ë³´ìœ  í¬ì§€ì…˜ ìƒì„¸ ({current_time})",
                box=box.ROUNDED,
                show_header=True,
                header_style="bold cyan"
            )
            holdings_table.add_column("No", style="cyan", justify="right", width=4)
            holdings_table.add_column("ì½”ë“œ", style="yellow", width=8)
            holdings_table.add_column("ì¢…ëª©ëª…", style="white", width=12)
            holdings_table.add_column("AIì ìˆ˜", justify="right", width=7)
            holdings_table.add_column("ìŠ¹ë¥ ", justify="right", width=7)
            holdings_table.add_column("ë§¤ìˆ˜ê°€", justify="right", width=9)
            holdings_table.add_column("ìˆ˜ëŸ‰", justify="right", width=6)
            holdings_table.add_column("í˜„ì¬ê°€", justify="right", width=9)
            holdings_table.add_column("ìˆ˜ìµë¥ ", justify="right", width=9)
            holdings_table.add_column("ì†ì ˆê°€", justify="right", width=9)
            holdings_table.add_column("ë³´ìœ ì¼", justify="right", width=7)

            for idx, (stock_code, position) in enumerate(self.positions.items(), 1):
                # ë‘ ê°€ì§€ í‚¤ í˜•ì‹ ëª¨ë‘ ì§€ì› (name/stock_name, price/avg_price/entry_price)
                stock_name = position.get('stock_name') or position.get('name', stock_code)
                entry_price = position.get('avg_price') or position.get('entry_price') or position.get('price', 0)
                quantity = position.get('quantity', 0)

                # ì „ëµ ì •ë³´ (validated_stocksì—ì„œ ê°€ì ¸ì˜¤ê±°ë‚˜ ìƒˆë¡œ ê³„ì‚°)
                db_candidate = None  # DB í›„ë³´ ì¢…ëª© (ë³´ìœ ì¼ ê³„ì‚°ìš©)
                stock_info = self.validated_stocks.get(stock_code)

                if stock_info:
                    win_rate = stock_info['stats'].get('win_rate', 0)
                    analysis = stock_info.get('analysis', {})
                    ai_score = analysis.get('total_score', 0)
                else:
                    # validated_stocksì— ì—†ìœ¼ë©´ DBì—ì„œ ì¡°íšŒ
                    from database.trading_db import TradingDatabase
                    db = TradingDatabase()
                    candidates = db.get_active_candidates()

                    for c in candidates:
                        if c.get('stock_code') == stock_code:
                            db_candidate = c
                            break

                    if db_candidate:
                        # DBì—ì„œ ê°€ì ¸ì˜¤ê¸°
                        win_rate = db_candidate.get('vwap_win_rate', 0)
                        ai_score = db_candidate.get('total_score', 0)
                    else:
                        # DBì—ë„ ì—†ìœ¼ë©´ ì‹¤ì‹œê°„ ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰
                        console.print(f"[yellow]  âš ï¸  {stock_code}: ì „ëµ ì •ë³´ ì—†ìŒ, ì‹¤ì‹œê°„ ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰[/yellow]")

                        # stock_dataì—ì„œ í•´ë‹¹ ì¢…ëª©ì˜ historical data ê°€ì ¸ì˜¤ê¸°
                        historical_df = None
                        for data in stock_data:
                            if data['code'] == stock_code and 'historical_df' in data:
                                historical_df = data['historical_df']
                                break

                        if historical_df is not None and len(historical_df) >= 100:
                            # VWAP ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰
                            from analyzers.pre_trade_validator import PreTradeValidator
                            validator = PreTradeValidator(self.config)
                            trades = validator._run_quick_simulation(historical_df)
                            stats = validator._calculate_stats(trades)

                            win_rate = stats.get('win_rate', 0)
                            ai_score = min(100, win_rate * 1.2)  # ê°„ì´ AIì ìˆ˜ (ìŠ¹ë¥  * 1.2)

                            console.print(f"[dim]  âœ“ {stock_code}: ë°±í…ŒìŠ¤íŠ¸ ì™„ë£Œ - ìŠ¹ë¥  {win_rate:.1f}%[/dim]")
                        else:
                            win_rate = 0
                            ai_score = 0

                # AI ì ìˆ˜ì™€ ìŠ¹ë¥ ì„ ìºì‹œì— ì €ì¥
                position_scores[stock_code] = {
                    'ai_score': ai_score,
                    'win_rate': win_rate
                }

                # í˜„ì¬ê°€ ì¡°íšŒ (ìš°ì„ ìˆœìœ„: position > stock_data)
                current_price = position.get('current_price') or entry_price  # ê¸°ë³¸ê°’
                for data in stock_data:
                    if data['code'] == stock_code:
                        current_price = data['price']
                        break

                # ìˆ˜ìµë¥  ê³„ì‚°
                profit_loss_pct = ((current_price - entry_price) / entry_price * 100) if entry_price > 0 else 0

                # ì†ì ˆê°€ ê³„ì‚° (5% ì†ì ˆ ê¸°ì¤€)
                stop_loss_price = entry_price * 0.95

                # ë³´ìœ ì¼ ê³„ì‚° (ìš°ì„ ìˆœìœ„: position.entry_date > DB.date_detected)
                entry_date = position.get('entry_date')

                if entry_date:
                    if isinstance(entry_date, str):
                        try:
                            entry_date = datetime.fromisoformat(entry_date)
                        except:
                            entry_date = None

                # entry_dateê°€ ì—†ìœ¼ë©´ DBì—ì„œ date_detected ì¡°íšŒ
                if not entry_date and db_candidate:
                    detected_date = db_candidate.get('date_detected')
                    if detected_date:
                        try:
                            if isinstance(detected_date, str):
                                entry_date = datetime.fromisoformat(detected_date)
                            else:
                                entry_date = detected_date
                        except:
                            pass

                # ë³´ìœ ì¼ ê³„ì‚°
                if entry_date:
                    hold_days = (datetime.now() - entry_date).days
                else:
                    hold_days = 0

                # ìˆ˜ìµë¥  ìƒ‰ìƒ
                if profit_loss_pct >= 2:
                    profit_color = "bold green"
                elif profit_loss_pct >= 0:
                    profit_color = "green"
                elif profit_loss_pct >= -2:
                    profit_color = "yellow"
                else:
                    profit_color = "red"

                # ìŠ¹ë¥  ìƒ‰ìƒ
                wr_color = "green" if win_rate >= 60 else "yellow" if win_rate >= 40 else "red"

                # AI ì ìˆ˜ ìƒ‰ìƒ
                ai_color = "bold green" if ai_score >= 70 else "green" if ai_score >= 60 else "yellow" if ai_score >= 50 else "red"

                holdings_table.add_row(
                    str(idx),
                    stock_code,
                    stock_name[:10],  # ìµœëŒ€ 10ì
                    f"[{ai_color}]{ai_score:.0f}[/{ai_color}]" if ai_score > 0 else "-",
                    f"[{wr_color}]{win_rate:.0f}%[/{wr_color}]" if win_rate > 0 else "-",
                    f"{entry_price:,.0f}",
                    str(quantity),
                    f"{current_price:,.0f}",
                    f"[{profit_color}]{profit_loss_pct:+.2f}%[/{profit_color}]",
                    f"{stop_loss_price:,.0f}",
                    f"{hold_days}ì¼"
                )

            console.print(holdings_table)
            console.print()

        # ì¢…ëª© ìˆ˜ í™•ì¸
        if len(stock_data) == 0:
            console.print("[yellow]âš ï¸  ëª¨ë‹ˆí„°ë§ ì¤‘ì¸ ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤.[/yellow]")
            console.print(f"[dim]watchlist: {len(self.watchlist)}ê°œ[/dim]")
            console.print(f"[dim]validated_stocks: {len(self.validated_stocks)}ê°œ[/dim]")
            return

        # ========================================
        # 1. ì‹œë®¬ë ˆì´ì…˜ í†µê³„ ìš”ì•½ í…Œì´ë¸”
        # ========================================
        sim_table = Table(title=f"ğŸ“ˆ ì‹œë®¬ë ˆì´ì…˜ í†µê³„ ìš”ì•½ ({current_time})", box=box.ROUNDED, show_header=True, header_style="bold cyan")
        sim_table.add_column("ìˆœë²ˆ", style="cyan", justify="right", width=4)
        sim_table.add_column("ì½”ë“œ", style="yellow", width=8)
        sim_table.add_column("ì¢…ëª©ëª…", style="white", width=12)
        sim_table.add_column("AIì ìˆ˜", justify="right", width=7)
        sim_table.add_column("ì´ê±°ë˜", justify="right", width=7)
        sim_table.add_column("ìŠ¹ë¥ ", justify="right", width=7)
        sim_table.add_column("í‰ê· ìˆ˜ìµ", justify="right", width=9)
        sim_table.add_column("ìµœëŒ€ìˆ˜ìµ", justify="right", width=9)
        sim_table.add_column("ìµœëŒ€ì†ì‹¤", justify="right", width=9)

        for i, data in enumerate(stock_data, 1):
            stock_code = data['code']
            stock_info = self.validated_stocks.get(stock_code)

            # ë³´ìœ  ì¢…ëª©ì´ì§€ë§Œ validated_stocksì— ì—†ëŠ” ê²½ìš° ìºì‹œì—ì„œ ê°€ì ¸ì˜¤ê¸°
            ai_score = 0  # ê¸°ë³¸ê°’
            if not stock_info:
                if stock_code in self.positions:
                    # ë³´ìœ  í¬ì§€ì…˜ í…Œì´ë¸”ì—ì„œ ê³„ì‚°í•œ ê°’ ì‚¬ìš©
                    cached = position_scores.get(stock_code, {})
                    ai_score = cached.get('ai_score', 0)
                    cached_win_rate = cached.get('win_rate', 0)

                    # âœ… FIX: historical_dfê°€ ìˆìœ¼ë©´ ì‹¤ì œ ë°±í…ŒìŠ¤íŠ¸ stats ì‚¬ìš©
                    historical_df = None
                    for d in stock_data:
                        if d['code'] == stock_code and 'historical_df' in d:
                            historical_df = d['historical_df']
                            break

                    if historical_df is not None and len(historical_df) >= 100:
                        # ì‹¤ì‹œê°„ ë°±í…ŒìŠ¤íŠ¸ë¡œ ì •í™•í•œ stats ê³„ì‚°
                        from analyzers.pre_trade_validator import PreTradeValidator
                        validator = PreTradeValidator(self.config)
                        trades = validator._run_quick_simulation(historical_df)
                        stats = validator._calculate_stats(trades)
                    else:
                        # ë°±í…ŒìŠ¤íŠ¸ ë¶ˆê°€ëŠ¥í•˜ë©´ ê¸°ë³¸ê°’
                        stats = {
                            'total_trades': 0,
                            'winning_trades': 0,
                            'losing_trades': 0,
                            'win_rate': cached_win_rate,  # ìºì‹œëœ ìŠ¹ë¥  ì‚¬ìš©
                            'avg_profit_pct': 0,
                            'max_profit_pct': 0,
                            'max_loss_pct': 0
                        }
                else:
                    continue
            else:
                # ì‹¤ì‹œê°„ ë°±í…ŒìŠ¤íŠ¸ë¡œ ìµœì‹  stats ê³„ì‚°
                historical_df = None
                for d in stock_data:
                    if d['code'] == stock_code and 'historical_df' in d:
                        historical_df = d['historical_df']
                        break

                if historical_df is not None and len(historical_df) >= 100:
                    # ì‹¤ì‹œê°„ ë°ì´í„°ë¡œ ì¬ê³„ì‚°
                    from analyzers.pre_trade_validator import PreTradeValidator
                    validator = PreTradeValidator(self.config)
                    trades = validator._run_quick_simulation(historical_df)
                    stats = validator._calculate_stats(trades)
                else:
                    # ì €ì¥ëœ stats ì‚¬ìš©
                    stats = stock_info['stats']

                analysis = stock_info.get('analysis', {})
                ai_score = analysis.get('total_score', 0) if analysis else 0

            total_trades = stats.get('total_trades', 0)
            win_rate = stats.get('win_rate', 0)
            avg_profit = stats.get('avg_profit_pct', 0)
            max_profit = stats.get('max_profit_pct', 0)
            max_loss = stats.get('max_loss_pct', 0)

            # AI ì ìˆ˜ ì•ˆì „ ì²˜ë¦¬ (None ì²´í¬)
            ai_score = ai_score if ai_score is not None else 0

            # AI ì ìˆ˜ ìƒ‰ìƒ
            ai_color = "bold green" if ai_score >= 70 else "green" if ai_score >= 60 else "yellow" if ai_score >= 50 else "red"

            # ìŠ¹ë¥  ìƒ‰ìƒ
            wr_color = "green" if win_rate >= 60 else "yellow" if win_rate >= 40 else "red"

            # í‰ê· ìˆ˜ìµ ìƒ‰ìƒ
            avg_color = "green" if avg_profit >= 2 else "yellow" if avg_profit >= 1 else "red"

            sim_table.add_row(
                str(i),
                data['code'],
                data['name'],
                f"[{ai_color}]{ai_score:.0f}[/{ai_color}]" if ai_score > 0 else "-",
                str(total_trades),
                f"[{wr_color}]{win_rate:.1f}%[/{wr_color}]",
                f"[{avg_color}]{avg_profit:+.2f}%[/{avg_color}]",
                f"[green]{max_profit:+.2f}%[/green]",
                f"[red]{max_loss:+.2f}%[/red]"
            )

        console.print(sim_table)
        console.print()

        # ========================================
        # 2. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ í…Œì´ë¸” (ë§¤ìˆ˜ ì¡°ê±´)
        # ========================================
        # ë³´ìœ  ì¢…ëª© ê°œìˆ˜ í™•ì¸
        holding_count = sum(1 for data in stock_data if data.get('holding'))
        monitoring_count = len(stock_data) - holding_count

        table_title = f"ğŸ“Š ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ({current_time})"
        if holding_count > 0:
            table_title += f" | [bold green]ë³´ìœ ì¢…ëª© {holding_count}ê°œ[/bold green]"
        if monitoring_count > 0:
            table_title += f" | ëª¨ë‹ˆí„°ë§ {monitoring_count}ê°œ"

        table = Table(title=table_title, box=box.ROUNDED, show_header=True, header_style="bold magenta")
        table.add_column("ìˆœë²ˆ", style="cyan", justify="right", width=4)
        table.add_column("ì½”ë“œ", style="yellow", width=8)
        table.add_column("ì¢…ëª©ëª…", style="white", width=16)
        table.add_column("ë³´ìœ ", justify="center", width=6)
        table.add_column("í˜„ì¬ê°€", justify="right", width=10)
        table.add_column("VWAP", justify="right", width=10)
        table.add_column("MA20", justify="right", width=10)
        table.add_column("ê±°ë˜ëŸ‰ì¦ê°", justify="right", width=10)
        table.add_column("ì‹œê·¸ë„", justify="center", width=10)
        table.add_column("ì²´í¬ì‹œê°„", style="dim", width=10)

        for i, data in enumerate(stock_data, 1):
            # VWAP ì¡°ê±´ ìƒ‰ìƒ
            vwap_str = f"{data['vwap']:,.0f}"
            if data['vwap_ok']:
                vwap_str = f"[green]{vwap_str} âœ“[/green]"
            else:
                vwap_str = f"[red]{vwap_str} âœ—[/red]"

            # MA20 ì¡°ê±´ ìƒ‰ìƒ
            ma20_str = f"{data['ma20']:,.0f}"
            if data['ma20_ok']:
                ma20_str = f"[green]{ma20_str} âœ“[/green]"
            else:
                ma20_str = f"[red]{ma20_str} âœ—[/red]"

            # ê±°ë˜ëŸ‰ ì¦ê° ìƒ‰ìƒ
            vol_change_str = f"{data['volume_change_pct']:+.1f}%"
            if data['volume_ok']:
                vol_change_str = f"[green]{vol_change_str} âœ“[/green]"
            else:
                vol_change_str = f"[red]{vol_change_str} âœ—[/red]"

            # ì‹œê·¸ë„ ìƒ‰ìƒ
            signal_color = data['signal_color']
            signal_str = f"[{signal_color}]{data['signal']}[/{signal_color}]"

            # ë³´ìœ  ì¢…ëª©ì¼ ë•Œ ì¢…ëª©ëª… ê°•ì¡°
            stock_name = data['name']
            if data['holding']:
                stock_name = f"[bold green]{stock_name}[/bold green]"

            table.add_row(
                str(i),
                data['code'],
                stock_name,  # ë³´ìœ  ì¢…ëª©ì€ ê°•ì¡°
                data['holding'],  # ë³´ìœ  ì—¬ë¶€ ì¶”ê°€
                f"{data['price']:,.0f}",
                vwap_str,
                ma20_str,
                vol_change_str,
                signal_str,
                data['time']
            )

        # ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ í…Œì´ë¸” ì¶œë ¥
        console.print(table)
        console.print()
        console.print(f"[dim]ë‹¤ìŒ ì²´í¬: 60ì´ˆ í›„ | Ctrl+C: ì¢…ë£Œ[/dim]")

    async def check_entry_signal(self, stock_code: str, kiwoom_df: pd.DataFrame = None):
        """ë§¤ìˆ˜ ì‹ í˜¸ ì²´í¬ (SignalOrchestrator ì‚¬ìš© - L0~L6 í†µí•©)"""
        try:
            console.print(f"[dim]ğŸ” {stock_code}: ë§¤ìˆ˜ ì‹ í˜¸ ì²´í¬ ì‹œì‘[/dim]")

            stock_info = self.validated_stocks.get(stock_code)
            if not stock_info:
                return

            stock_name = stock_info.get('name', stock_code)
            market = stock_info.get('market', 'KOSPI')

            # 1. ë°ì´í„° ì¡°íšŒ (í‚¤ì›€ ìš°ì„ , Yahoo Finance í´ë°±)
            if kiwoom_df is not None and len(kiwoom_df) >= 50:
                df = kiwoom_df.copy()
            else:
                # Yahoo Finance fallback
                ticker_suffix = '.KS' if market == 'KOSPI' else '.KQ'
                ticker = f"{stock_code}{ticker_suffix}"
                df = download_stock_data_sync(ticker, days=1)

                if df is None or len(df) < 50:
                    # ë°˜ëŒ€ ì‹œì¥ ì‹œë„
                    ticker_alt = f"{stock_code}.KQ" if market == 'KOSPI' else f"{stock_code}.KS"
                    df = download_stock_data_sync(ticker_alt, days=1)

                if df is None or len(df) < 50:
                    console.print(f"[yellow]âš ï¸  {stock_code}: ë°ì´í„° ë¶€ì¡±[/yellow]")
                    return

            # ì»¬ëŸ¼ëª… ì†Œë¬¸ì ë³€í™˜
            if isinstance(df.columns, pd.MultiIndex):
                df.columns = [col[0].lower() if isinstance(col, tuple) else col.lower() for col in df.columns]
            else:
                df.columns = df.columns.str.lower()

            # ğŸš¨ ìŒìˆ˜/0 ê°€ê²© í•„í„°ë§
            if 'close' in df.columns:
                invalid_rows = df[df['close'] <= 0]
                if len(invalid_rows) > 0:
                    console.print(f"[yellow]âš ï¸  {stock_code}: {len(invalid_rows)}ê°œ ë¹„ì •ìƒ ê°€ê²© ì œê±°[/yellow]")
                    df = df[df['close'] > 0].copy()

                if len(df) < 50:
                    console.print(f"[yellow]âš ï¸  {stock_code}: í•„í„°ë§ í›„ ë°ì´í„° ë¶€ì¡±[/yellow]")
                    return

            # VWAP ê³„ì‚°
            vwap_config = self.config.get_section('vwap')
            df = self.analyzer.calculate_vwap(df,
                                               use_rolling=vwap_config.get('use_rolling', True),
                                               rolling_window=vwap_config.get('rolling_window', 20))
            df = self.analyzer.calculate_atr(df)

            signal_config = self.config.get_signal_generation_config()
            df = self.analyzer.generate_signals(df, **signal_config)

            current_price = df['close'].iloc[-1]

            # ğŸš¨ ìŒìˆ˜ ê°€ê²© ìµœì¢… ê²€ì¦
            if current_price <= 0:
                console.print(f"[red]âŒ {stock_code}: ë¹„ì •ìƒ í˜„ì¬ê°€ {current_price}[/red]")
                return

            # 2. SignalOrchestratorë¡œ ì „ì²´ ì‹œê·¸ë„ í‰ê°€ (L0~L6)
            signal_result = self.signal_orchestrator.evaluate_signal(
                stock_code=stock_code,
                stock_name=stock_name,
                current_price=current_price,
                df=df,
                market=market,
                current_cash=self.current_cash,
                daily_pnl=self.calculate_daily_pnl()
            )

            # 3. ì‹œê·¸ë„ ê²°ê³¼ ì²˜ë¦¬
            if not signal_result['allowed']:
                level = signal_result['rejection_level']
                reason = signal_result['rejection_reason']
                console.print(f"[yellow]âš ï¸  {stock_name} ({stock_code}): {level} ì°¨ë‹¨ - {reason}[/yellow]")
                return

            # 4. ë§¤ìˆ˜ ì‹¤í–‰
            tier = signal_result['tier']
            position_size_mult = signal_result['position_size_multiplier']

            console.print(f"[green]âœ… {stock_name} ({stock_code}): ë§¤ìˆ˜ ì‹œê·¸ë„ ë°œìƒ![/green]")
            console.print(f"  Tier: {tier}, í¬ì§€ì…˜ ì¡°ì •: {position_size_mult*100:.0f}%")

            # execute_buy í˜¸ì¶œ (í¬ì§€ì…˜ ì‚¬ì´ì¦ˆ ë°˜ì˜)
            self.execute_buy(stock_code, stock_name, current_price, df, position_size_mult)

        except Exception as e:
            console.print(f"[red]âŒ {stock_code} ë§¤ìˆ˜ ì‹ í˜¸ ì²´í¬ ì‹¤íŒ¨: {e}[/red]")
            import traceback
            traceback.print_exc()

    def check_exit_signal(self, stock_code: str, kiwoom_df: pd.DataFrame = None):
        """ë§¤ë„ ì‹ í˜¸ ì²´í¬ - ìµœì í™”ëœ ì²­ì‚° ë¡œì§ ì‚¬ìš©"""
        try:
            console.print(f"[dim]ğŸ” {stock_code}: ë§¤ë„ ì‹ í˜¸ ì²´í¬ ì‹œì‘[/dim]")

            position = self.positions.get(stock_code)
            if not position:
                console.print(f"[yellow]âš ï¸  {stock_code}: í¬ì§€ì…˜ ì •ë³´ ì—†ìŒ[/yellow]")
                return

            # í¬ì§€ì…˜ ê¸°ë³¸ê°’ ì„¤ì •
            position.setdefault('entry_price', position.get('avg_price', 0))
            position.setdefault('highest_price', position['entry_price'])
            position.setdefault('trailing_active', False)
            position.setdefault('trailing_stop_price', None)
            position.setdefault('partial_exit_stage', 0)

            # 1ìˆœìœ„: í‚¤ì›€ API ë°ì´í„° ì‚¬ìš© (ì´ë¯¸ ì¡°íšŒëœ ë°ì´í„°)
            if kiwoom_df is not None and len(kiwoom_df) >= 50:
                console.print(f"[dim]  âœ“ {stock_code}: í‚¤ì›€ ë°ì´í„° ì‚¬ìš© ({len(kiwoom_df)}ë´‰)[/dim]")
                df = kiwoom_df.copy()
            else:
                # 2ìˆœìœ„: Yahoo Financeì—ì„œ ë³´ì¶©
                market = None
                if stock_code in self.validated_stocks:
                    market = self.validated_stocks[stock_code].get('market')

                if not market:
                    market = 'KOSPI' if stock_code.startswith('0') else 'KOSDAQ'

                ticker_suffix = '.KS' if market == 'KOSPI' else '.KQ'
                ticker = f"{stock_code}{ticker_suffix}"

                console.print(f"[dim]  ğŸ“Š {stock_code}: Yahoo ë°ì´í„° ì¡°íšŒ ì¤‘ ({ticker})...[/dim]")
                df = download_stock_data_sync(ticker, days=1)

                if df is None or len(df) < 50:
                    console.print(f"[yellow]âš ï¸  {stock_code}: ë°ì´í„° ë¶€ì¡± (df={len(df) if df is not None else 0}ë´‰)[/yellow]")
                    return

            # VWAP ì„¤ì • ë° ê³„ì‚°
            vwap_config = self.config.get_section('vwap')
            use_rolling = vwap_config.get('use_rolling', True)
            rolling_window = vwap_config.get('rolling_window', 20)

            df = self.analyzer.calculate_vwap(df, use_rolling=use_rolling, rolling_window=rolling_window)
            df = self.analyzer.calculate_atr(df)

            signal_config = self.config.get_signal_generation_config()
            df = self.analyzer.generate_signals(df, **signal_config)

            current_price = df['close'].iloc[-1]

            # ğŸš¨ ìŒìˆ˜ ê°€ê²© ê²€ì¦
            if current_price <= 0:
                console.print(f"[red]âŒ {stock_code}: ë¹„ì •ìƒ í˜„ì¬ê°€ {current_price}[/red]")
                return

            # ìµœì í™”ëœ ì²­ì‚° ë¡œì§ í˜¸ì¶œ
            should_exit, exit_reason, exit_info = self.exit_logic.check_exit_signal(
                position=position,
                current_price=current_price,
                df=df
            )

            # ìˆ˜ìµë¥  ê³„ì‚°
            profit_pct = ((current_price - position['entry_price']) / position['entry_price']) * 100
            console.print(f"[dim]  ğŸ’° {stock_code}: í˜„ì¬ê°€ {current_price:,.0f}ì›, ì§„ì…ê°€ {position['entry_price']:,.0f}ì›, ìˆ˜ìµë¥  {profit_pct:+.2f}%[/dim]")

            # ë¶€ë¶„ ì²­ì‚° ì²˜ë¦¬
            if exit_info and exit_info.get('partial_exit'):
                self.execute_partial_sell(
                    stock_code=stock_code,
                    price=current_price,
                    profit_pct=profit_pct,
                    exit_ratio=exit_info.get('exit_ratio', 0.3),
                    stage=exit_info.get('stage', 1)
                )
                return

            # ì „ëŸ‰ ì²­ì‚° ì‹¤í–‰
            if should_exit:
                use_market_order = exit_info.get('use_market_order', False) if exit_info else False
                self.execute_sell(stock_code, current_price, profit_pct, exit_reason, use_market_order)

        except Exception as e:
            console.print(f"[red]âŒ {stock_code} ë§¤ë„ ì‹ í˜¸ ì²´í¬ ì‹¤íŒ¨: {e}[/red]")

    def calculate_daily_pnl(self) -> float:
        """ê¸ˆì¼ ì†ìµ ê³„ì‚° (L0 ì‹œìŠ¤í…œ í•„í„°ìš©)"""
        try:
            # DBì—ì„œ ì˜¤ëŠ˜ ê±°ë˜ ì¡°íšŒ
            today = datetime.now().strftime('%Y-%m-%d')

            trades_today = self.db.get_trades()  # ì „ì²´ ì¡°íšŒ í›„ í•„í„°

            total_pnl = 0.0
            for trade in trades_today:
                trade_time = trade.get('trade_time', '')
                if trade_time.startswith(today):
                    realized_profit = trade.get('realized_profit', 0)
                    if realized_profit:
                        total_pnl += float(realized_profit)

            return total_pnl

        except Exception as e:
            console.print(f"[dim]âš ï¸  ì¼ì¼ ì†ìµ ê³„ì‚° ì‹¤íŒ¨: {e}[/dim]")
            return 0.0

    def execute_buy(self, stock_code: str, stock_name: str, price: float, df: pd.DataFrame, position_size_mult: float = 1.0):
        """ë§¤ìˆ˜ ì‹¤í–‰ (ì‹¤ê³„ì¢Œ ê¸°ë°˜ ë¦¬ìŠ¤í¬ ê´€ë¦¬ + SignalOrchestrator í¬ì§€ì…˜ ì¡°ì •)"""
        console.print()
        console.print("=" * 80, style="green")
        console.print(f"ğŸ”” ë§¤ìˆ˜ ì‹ í˜¸ ë°œìƒ: {stock_name} ({stock_code})", style="bold green")
        console.print(f"   ê°€ê²©: {price:,.0f}ì›")
        console.print(f"   ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

        # ì‹¤ê³„ì¢Œ ê¸°ë°˜ í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
        if not self.risk_manager:
            console.print("[red]âŒ ë¦¬ìŠ¤í¬ ê´€ë¦¬ìê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.[/red]")
            return

        trailing_cfg = self.config.get_trailing_config()
        stop_loss_pct = trailing_cfg.get('stop_loss_pct', getattr(self.analyzer, 'stop_loss_pct', 3.0))

        # ì†ì ˆê°€ ê³„ì‚° (ì„¤ì • ê¸°ë°˜)
        stop_loss_price = price * (1 - stop_loss_pct / 100)

        # í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
        position_calc = self.risk_manager.calculate_position_size(
            current_balance=self.current_cash,
            current_price=price,
            stop_loss_price=stop_loss_price,
            entry_confidence=1.0
        )

        # SignalOrchestratorì˜ í¬ì§€ì…˜ ì¡°ì • ë°˜ì˜
        quantity = int(position_calc['quantity'] * position_size_mult)
        amount = position_calc['investment'] * position_size_mult

        # ì§„ì… ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
        can_enter, reason = self.risk_manager.can_open_position(
            current_balance=self.current_cash,
            current_positions_value=self.positions_value,
            position_count=len(self.positions),
            position_size=amount
        )

        if not can_enter:
            console.print(f"[yellow]âš ï¸  ë§¤ìˆ˜ ë¶ˆê°€: {reason}[/yellow]")
            console.print("=" * 80, style="yellow")
            return

        console.print(f"[dim]ğŸ“Š í¬ì§€ì…˜ ê³„ì‚°:[/dim]")
        console.print(f"[dim]   - íˆ¬ìê¸ˆì•¡: {amount:,.0f}ì› (ë¦¬ìŠ¤í¬: {position_calc['risk_amount']:,.0f}ì›)[/dim]")
        console.print(f"[dim]   - ë§¤ìˆ˜ìˆ˜ëŸ‰: {quantity}ì£¼[/dim]")
        console.print(f"[dim]   - í¬ì§€ì…˜ë¹„ìœ¨: {position_calc['position_ratio']:.1f}%[/dim]")
        console.print(f"[dim]   - í¬ì§€ì…˜ ì¡°ì • ë°°ìˆ˜: {position_size_mult*100:.0f}%[/dim]")

        # Dry-run ëª¨ë“œ ì²´í¬
        if self.dry_run_mode:
            console.print()
            console.print("[cyan]ğŸ” [DRY-RUN] ë°±í…ŒìŠ¤íŠ¸ ëª¨ë“œ: ì‹¤ì œ ì£¼ë¬¸ ìƒëµ[/cyan]")
            console.print(f"[cyan]   â†’ ë§¤ìˆ˜ ì‹œê·¸ë„ í™•ì¸ ì™„ë£Œ: {stock_name} ({stock_code})[/cyan]")
            console.print(f"[cyan]   â†’ ì˜ˆìƒ ìˆ˜ëŸ‰: {quantity}ì£¼, ì˜ˆìƒ ê¸ˆì•¡: {amount:,.0f}ì›[/cyan]")
            console.print("=" * 80, style="cyan")
            return

        # ì‹¤ì œ í‚¤ì›€ API ë§¤ìˆ˜ ì£¼ë¬¸
        try:
            console.print(f"[yellow]ğŸ“¡ í‚¤ì›€ API ë§¤ìˆ˜ ì£¼ë¬¸ ì „ì†¡ ì¤‘...[/yellow]")
            order_result = self.api.order_buy(
                stock_code=stock_code,
                quantity=quantity,
                price=int(price),
                trade_type="0"  # ì§€ì •ê°€ ì£¼ë¬¸
            )

            if order_result.get('return_code') != 0:
                console.print(f"[red]âŒ ë§¤ìˆ˜ ì£¼ë¬¸ ì‹¤íŒ¨: {order_result.get('return_msg')}[/red]")
                return

            order_no = order_result.get('ord_no')
            console.print(f"[green]âœ“ ë§¤ìˆ˜ ì£¼ë¬¸ ì„±ê³µ - ì£¼ë¬¸ë²ˆí˜¸: {order_no}[/green]")

        except Exception as e:
            console.print(f"[red]âŒ ë§¤ìˆ˜ API í˜¸ì¶œ ì‹¤íŒ¨: {e}[/red]")
            return

        # í¬ì§€ì…˜ ìƒì„±
        entry_time = datetime.now()
        self.positions[stock_code] = {
            'stock_name': stock_name,  # ì”ê³  ì¡°íšŒì™€ í†µì¼
            'name': stock_name,  # í•˜ìœ„ í˜¸í™˜ì„±
            'avg_price': price,  # ì”ê³  ì¡°íšŒì™€ í†µì¼
            'entry_price': price,  # í•˜ìœ„ í˜¸í™˜ì„±
            'entry_time': entry_time,
            'entry_date': entry_time,  # ë³´ìœ ì¼ ê³„ì‚°ìš©
            'quantity': quantity,
            'initial_quantity': quantity,  # ì´ˆê¸° ìˆ˜ëŸ‰ (ë¶€ë¶„ ì²­ì‚° ì¶”ì ìš©)
            'current_price': price,  # ì´ˆê¸° í˜„ì¬ê°€
            'highest_price': price,
            'trailing_active': False,
            'trailing_stop_price': None,
            'trade_id': None,  # DB trade_id ì €ì¥ìš©
            'partial_exit_stage': 0,  # ë¶€ë¶„ ì²­ì‚° ë‹¨ê³„ (0: ë¯¸ì§„í–‰, 1: 1ì°¨ ì™„ë£Œ, 2: 2ì°¨ ì™„ë£Œ)
            'total_realized_profit': 0.0,  # ëˆ„ì  ì‹¤í˜„ ì†ìµ
            'order_no': order_no  # ì£¼ë¬¸ë²ˆí˜¸ ì €ì¥
        }

        # DBì— ë§¤ìˆ˜ ê±°ë˜ ì €ì¥
        stock_info = self.validated_stocks.get(stock_code, {})
        stats = stock_info.get('stats', {})
        analysis = stock_info.get('analysis', {})  # ì¢…í•© ë¶„ì„ ê²°ê³¼
        scores = analysis.get('scores', {})

        trade_data = {
            'stock_code': stock_code,
            'stock_name': stock_name,
            'trade_type': 'BUY',
            'trade_time': entry_time.isoformat(),
            'price': price,
            'quantity': quantity,
            'amount': amount,
            'condition_name': 'VWAP+AI',
            'strategy_config': 'hybrid',
            'entry_reason': f"VWAP ìƒí–¥ ëŒíŒŒ (ì¢…í•©ì ìˆ˜: {analysis.get('total_score', 0):.1f})",

            # VWAP ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼
            'vwap_validation_score': stats.get('avg_profit_pct', 0),
            'sim_win_rate': stats.get('win_rate'),
            'sim_avg_profit': stats.get('avg_profit_pct'),
            'sim_trade_count': stats.get('total_trades'),
            'sim_profit_factor': stats.get('profit_factor'),

            # ì¢…í•© ë¶„ì„ ê²°ê³¼ (AI)
            'total_score': analysis.get('total_score', 0),
            'score_news': scores.get('news', 50),
            'score_technical': scores.get('technical', 50),
            'score_supply_demand': scores.get('supply_demand', 50),
            'score_fundamental': scores.get('fundamental', 50),
            'recommendation': analysis.get('recommendation', 'ê´€ë§'),

            # ë‰´ìŠ¤ ë¶„ì„
            'news_sentiment': analysis.get('news_sentiment', 'neutral'),
            'news_impact': analysis.get('news_impact', 0),
            'news_keywords': [],
            'news_titles': []
        }

        trade_id = self.db.insert_trade(trade_data)
        self.positions[stock_code]['trade_id'] = trade_id

        # ë¦¬ìŠ¤í¬ ê´€ë¦¬ìì— ê±°ë˜ ê¸°ë¡
        self.risk_manager.record_trade(
            stock_code=stock_code,
            stock_name=stock_name,
            trade_type='BUY',
            quantity=quantity,
            price=price,
            realized_pnl=0
        )

        console.print(f"âœ… ë§¤ìˆ˜ ì™„ë£Œ (DB ID: {trade_id})")
        console.print("=" * 80, style="green")
        console.print()

        # ì”ê³  ì—…ë°ì´íŠ¸ (ë¹„ë™ê¸° ì‹¤í–‰ì€ ë‚˜ì¤‘ì—)
        # TODO: asyncio.create_task(self.update_account_balance())

    def execute_partial_sell(self, stock_code: str, price: float, profit_pct: float, exit_ratio: float, stage: int):
        """ë¶€ë¶„ ì²­ì‚° ì‹¤í–‰

        Args:
            stock_code: ì¢…ëª©ì½”ë“œ
            price: ë§¤ë„ê°€
            profit_pct: ìˆ˜ìµë¥ 
            exit_ratio: ì²­ì‚° ë¹„ìœ¨ (0.4 = 40%)
            stage: ì²­ì‚° ë‹¨ê³„ (1, 2)
        """
        position = self.positions.get(stock_code)
        if not position:
            return

        # ì²­ì‚°í•  ìˆ˜ëŸ‰ ê³„ì‚° (ì´ˆê¸° ìˆ˜ëŸ‰ ëŒ€ë¹„)
        initial_quantity = position.get('initial_quantity', position['quantity'])
        partial_quantity = int(initial_quantity * exit_ratio)

        # ìµœì†Œ 1ì£¼ëŠ” ì²­ì‚°í•´ì•¼ í•¨
        if partial_quantity < 1:
            return

        # í˜„ì¬ ë³´ìœ  ìˆ˜ëŸ‰ë³´ë‹¤ ë§ì´ íŒ” ìˆ˜ ì—†ìŒ
        if partial_quantity > position['quantity']:
            partial_quantity = position['quantity']

        # ì‹¤í˜„ ì†ìµ ê³„ì‚°
        realized_profit = (price - position['entry_price']) * partial_quantity

        if stage >= 2:
            trailing_cfg = self.config.get_trailing_config()
            ratio = trailing_cfg.get('ratio', getattr(self.analyzer, 'trailing_ratio', 1.0))
            ratio = max(ratio, 0.1)
            position['highest_price'] = max(position.get('highest_price', price), price)
            position['trailing_active'] = True
            position['trailing_stop_price'] = position['highest_price'] * (1 - ratio / 100)

        console.print()
        console.print("=" * 80, style="yellow")
        console.print(f"ğŸ¯ ë¶€ë¶„ ì²­ì‚° {stage}ë‹¨ê³„: {position['name']} ({stock_code})", style="bold yellow")
        console.print(f"   ë§¤ìˆ˜ê°€: {position['entry_price']:,.0f}ì›")
        console.print(f"   ë§¤ë„ê°€: {price:,.0f}ì›")
        console.print(f"   ìˆ˜ìµë¥ : {profit_pct:+.2f}%")
        console.print(f"   ì²­ì‚°ë¹„ìœ¨: {exit_ratio*100:.0f}% ({partial_quantity}/{initial_quantity}ì£¼)")
        console.print(f"   ì‹¤í˜„ì†ìµ: {realized_profit:+,.0f}ì›")
        console.print(f"   ë‚¨ì€ìˆ˜ëŸ‰: {position['quantity'] - partial_quantity}ì£¼")

        # DBì— ë¶€ë¶„ ë§¤ë„ ê±°ë˜ ì €ì¥
        trade_id = position.get('trade_id')
        if trade_id:
            entry_time = position.get('entry_time') or position.get('entry_date')
            holding_duration = (datetime.now() - entry_time).seconds if entry_time else 0

            partial_sell_trade = {
                'stock_code': stock_code,
                'stock_name': position['name'],
                'trade_type': 'SELL',
                'trade_time': datetime.now().isoformat(),
                'price': price,
                'quantity': partial_quantity,
                'amount': price * partial_quantity,
                'exit_reason': f'ë¶€ë¶„ì²­ì‚° {stage}ë‹¨ê³„ (+{profit_pct:.1f}%)',
                'realized_profit': realized_profit,
                'profit_rate': profit_pct,
                'holding_duration': holding_duration
            }
            self.db.insert_trade(partial_sell_trade)

        # ì‹¤ì œ í‚¤ì›€ API ë¶€ë¶„ ë§¤ë„ ì£¼ë¬¸
        try:
            console.print(f"[yellow]ğŸ“¡ í‚¤ì›€ API ë¶€ë¶„ ë§¤ë„ ì£¼ë¬¸ ì „ì†¡ ì¤‘...[/yellow]")
            order_result = self.api.order_sell(
                stock_code=stock_code,
                quantity=partial_quantity,
                price=0,  # ì‹œì¥ê°€ ë§¤ë„
                trade_type="3"  # ì‹œì¥ê°€
            )

            if order_result.get('return_code') != 0:
                console.print(f"[red]âŒ ë¶€ë¶„ ë§¤ë„ ì£¼ë¬¸ ì‹¤íŒ¨: {order_result.get('return_msg')}[/red]")
                console.print(f"[yellow]âš ï¸  í¬ì§€ì…˜ì€ ìœ ì§€ë©ë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ì²˜ë¦¬í•˜ì„¸ìš”.[/yellow]")
                return

            order_no = order_result.get('ord_no')
            console.print(f"[green]âœ“ ë¶€ë¶„ ë§¤ë„ ì£¼ë¬¸ ì„±ê³µ - ì£¼ë¬¸ë²ˆí˜¸: {order_no}[/green]")

        except Exception as e:
            console.print(f"[red]âŒ ë¶€ë¶„ ë§¤ë„ API í˜¸ì¶œ ì‹¤íŒ¨: {e}[/red]")
            console.print(f"[yellow]âš ï¸  í¬ì§€ì…˜ì€ ìœ ì§€ë©ë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ì²˜ë¦¬í•˜ì„¸ìš”.[/yellow]")
            return

        # ë¦¬ìŠ¤í¬ ê´€ë¦¬ìì— ê±°ë˜ ê¸°ë¡
        self.risk_manager.record_trade(
            stock_code=stock_code,
            stock_name=position['name'],
            trade_type='SELL',
            quantity=partial_quantity,
            price=price,
            realized_pnl=realized_profit
        )

        # í¬ì§€ì…˜ ì—…ë°ì´íŠ¸
        position['quantity'] -= partial_quantity
        position['partial_exit_stage'] = stage
        position['total_realized_profit'] += realized_profit

        console.print(f"âœ… ë¶€ë¶„ ì²­ì‚° ì™„ë£Œ (ì£¼ë¬¸ë²ˆí˜¸: {order_no})")
        console.print("=" * 80, style="yellow")
        console.print()

    def execute_sell(self, stock_code: str, price: float, profit_pct: float, reason: str, use_market_order: bool = False):
        """ë§¤ë„ ì‹¤í–‰ (ì „ëŸ‰ ì²­ì‚°)"""
        position = self.positions.get(stock_code)
        if not position:
            return

        # entry_timeì´ ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
        entry_time = position.get('entry_time') or position.get('entry_date')
        if entry_time:
            holding_duration = (datetime.now() - entry_time).seconds
        else:
            holding_duration = 0  # entry_time ì—†ìœ¼ë©´ 0ìœ¼ë¡œ ì„¤ì •

        realized_profit = (price - position['entry_price']) * position['quantity']

        console.print()
        console.print("=" * 80, style="red")
        console.print(f"ğŸ”” ë§¤ë„ ì‹ í˜¸ ë°œìƒ: {position['name']} ({stock_code})", style="bold red")
        console.print(f"   ë§¤ìˆ˜ê°€: {position['entry_price']:,.0f}ì›")
        console.print(f"   ë§¤ë„ê°€: {price:,.0f}ì›")
        console.print(f"   ìˆ˜ìµë¥ : {profit_pct:+.2f}%")
        console.print(f"   ì‹¤í˜„ì†ìµ: {realized_profit:+,.0f}ì›")
        console.print(f"   ì‚¬ìœ : {reason}")
        console.print(f"   ë³´ìœ ì‹œê°„: {holding_duration // 60}ë¶„")

        # DBì— ë§¤ë„ ì •ë³´ ì €ì¥ (ë§¤ìˆ˜ ì‹œ ìƒì„±í•œ trade ì—…ë°ì´íŠ¸)
        trade_id = position.get('trade_id')
        if trade_id:
            # ë§¤ë„ ê±°ë˜ ì¶”ê°€ (SELL) - numpy íƒ€ì…ì„ Python ê¸°ë³¸ íƒ€ì…ìœ¼ë¡œ ë³€í™˜
            sell_trade = {
                'stock_code': stock_code,
                'stock_name': position['name'],
                'trade_type': 'SELL',
                'trade_time': datetime.now().isoformat(),
                'price': float(price),
                'quantity': int(position['quantity']),
                'amount': float(price * position['quantity']),
                'exit_reason': reason,
                'realized_profit': float(realized_profit),
                'profit_rate': float(profit_pct),
                'holding_duration': int(holding_duration)
            }
            self.db.insert_trade(sell_trade)

        # ì‹¤ì œ í‚¤ì›€ API ë§¤ë„ ì£¼ë¬¸
        try:
            if use_market_order:
                # Emergency Hard Stop: ì‹œì¥ê°€ ì£¼ë¬¸
                console.print(f"[red]ğŸ“¡ ê¸´ê¸‰ ì‹œì¥ê°€ ë§¤ë„ ì£¼ë¬¸ ì „ì†¡ ì¤‘...[/red]")
                order_result = self.api.order_sell(
                    stock_code=stock_code,
                    quantity=position['quantity'],
                    price=0,  # ì‹œì¥ê°€
                    trade_type="3"  # ì‹œì¥ê°€
                )
            else:
                # ì¼ë°˜ ì²­ì‚°: í˜„ì¬ê°€ ì§€ì •ê°€ ì£¼ë¬¸
                console.print(f"[yellow]ğŸ“¡ í‚¤ì›€ API ë§¤ë„ ì£¼ë¬¸ ì „ì†¡ ì¤‘...[/yellow]")
                order_result = self.api.order_sell(
                    stock_code=stock_code,
                    quantity=position['quantity'],
                    price=int(price),  # í˜„ì¬ê°€ë¡œ ì§€ì •ê°€
                    trade_type="0"  # ì§€ì •ê°€
                )

            if order_result.get('return_code') != 0:
                console.print(f"[red]âŒ ë§¤ë„ ì£¼ë¬¸ ì‹¤íŒ¨: {order_result.get('return_msg')}[/red]")
                console.print(f"[yellow]âš ï¸  í¬ì§€ì…˜ì€ ìœ ì§€ë©ë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ì²˜ë¦¬í•˜ì„¸ìš”.[/yellow]")
                return

            order_no = order_result.get('ord_no')
            console.print(f"[green]âœ“ ë§¤ë„ ì£¼ë¬¸ ì„±ê³µ - ì£¼ë¬¸ë²ˆí˜¸: {order_no}[/green]")

        except Exception as e:
            console.print(f"[red]âŒ ë§¤ë„ API í˜¸ì¶œ ì‹¤íŒ¨: {e}[/red]")
            console.print(f"[yellow]âš ï¸  í¬ì§€ì…˜ì€ ìœ ì§€ë©ë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ì²˜ë¦¬í•˜ì„¸ìš”.[/yellow]")
            return

        # ë¦¬ìŠ¤í¬ ê´€ë¦¬ìì— ê±°ë˜ ê¸°ë¡
        self.risk_manager.record_trade(
            stock_code=stock_code,
            stock_name=position['name'],
            trade_type='SELL',
            quantity=position['quantity'],
            price=price,
            realized_pnl=realized_profit
        )

        # í¬ì§€ì…˜ ì œê±°
        del self.positions[stock_code]

        console.print(f"âœ… ë§¤ë„ ì™„ë£Œ (ì£¼ë¬¸ë²ˆí˜¸: {order_no})")
        console.print("=" * 80, style="red")
        console.print()

        # ì”ê³  ì—…ë°ì´íŠ¸ (ë¹„ë™ê¸° ì‹¤í–‰ì€ ë‚˜ì¤‘ì—)
        # TODO: asyncio.create_task(self.update_account_balance())

    def load_candidates_from_db(self):
        """DBì—ì„œ í™œì„± ê°ì‹œ ì¢…ëª© ë¡œë“œ"""
        try:
            candidates = self.db.get_active_candidates(limit=100)

            if not candidates:
                console.print("  âš ï¸  DBì— í™œì„± ê°ì‹œ ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤. ì¡°ê±´ê²€ìƒ‰ì„ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”.", style="yellow")
                return

            console.print(f"  âœ… DBì—ì„œ {len(candidates)}ê°œ í™œì„± ì¢…ëª© ë¡œë“œ", style="green")

            # watchlist ë° validated_stocks êµ¬ì„±
            for candidate in candidates:
                stock_code = candidate['stock_code']
                stock_name = candidate['stock_name']

                self.watchlist.add(stock_code)
                self.validated_stocks[stock_code] = {
                    'name': stock_name,
                    'market': candidate.get('market', 'KOSPI'),  # ì‹œì¥ ì •ë³´ ì¶”ê°€
                    'stats': {
                        'win_rate': candidate.get('vwap_win_rate', 0),
                        'avg_profit_pct': candidate.get('vwap_avg_profit', 0),
                        'total_trades': candidate.get('vwap_trade_count', 0),
                        'profit_factor': candidate.get('vwap_profit_factor', 0)
                    },
                    # ì¢…í•© ë¶„ì„ ê²°ê³¼ (ì¡°ê±´ê²€ìƒ‰ í•„í„°ì—ì„œ ì¶”ê°€ëœ ë°ì´í„°)
                    'analysis': {
                        'total_score': candidate.get('total_score', 0),
                        'recommendation': candidate.get('recommendation', 'ê´€ë§'),
                        'action': candidate.get('action', 'HOLD'),
                        'scores': {
                            'news': candidate.get('score_news', 50),
                            'technical': candidate.get('score_technical', 50),
                            'supply_demand': candidate.get('score_supply_demand', 50),
                            'fundamental': candidate.get('score_fundamental', 50),
                            'vwap': candidate.get('score_vwap', 0)
                        },
                        'news_sentiment': candidate.get('news_sentiment', 'neutral'),
                        'news_impact': candidate.get('news_impact', 0)
                    },
                    'ticker': f"{stock_code}.KS",
                    'db_id': candidate['id']  # DB ID ì €ì¥
                }

            console.print(f"  ğŸ“‹ ê°ì‹œ ì¢…ëª©: {', '.join([self.validated_stocks[c]['name'] for c in list(self.watchlist)[:5]])}{'...' if len(self.watchlist) > 5 else ''}", style="dim")
            console.print()

        except Exception as e:
            console.print(f"  âŒ DB ë¡œë“œ ì‹¤íŒ¨: {e}", style="red")
            import traceback
            traceback.print_exc()

    def shutdown(self):
        """ì‹œìŠ¤í…œ ì¢…ë£Œ"""
        self.running = False

        console.print()
        console.print("[yellow]âš ï¸  ì¢…ë£Œ ì‹ í˜¸ ê°ì§€... ì•ˆì „í•˜ê²Œ ì¢…ë£Œí•©ë‹ˆë‹¤.[/yellow]")
        console.print()

        # ë¯¸ì²­ì‚° í¬ì§€ì…˜ í‘œì‹œ
        if self.positions:
            console.print(f"[yellow]âš ï¸  ë¯¸ì²­ì‚° í¬ì§€ì…˜: {len(self.positions)}ê°œ[/yellow]")

            for code, pos in self.positions.items():
                console.print(f"  - {pos['name']} ({code}): {pos['entry_price']:,.0f}ì›ì— ë§¤ìˆ˜")

            console.print()

        console.print("[green]âœ… ìë™ ë§¤ë§¤ ì¢…ë£Œ ì™„ë£Œ[/green]")
        console.print()

    async def wait_until_time(self, target_hour: int, target_minute: int):
        """íŠ¹ì • ì‹œê°ê¹Œì§€ ëŒ€ê¸°"""
        import sys
        import select

        # stdin ë²„í¼ ë¹„ìš°ê¸° (ë‚¨ì•„ìˆëŠ” ì…ë ¥ ì œê±°)
        try:
            while sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
                sys.stdin.readline()
        except Exception:
            pass  # Windows ë“±ì—ì„œ select ë¯¸ì§€ì› ì‹œ ë¬´ì‹œ

        # ëª©í‘œ ì‹œê°„ ê³„ì‚°
        now = datetime.now()

        if now.weekday() >= 5:  # í† ìš”ì¼(5), ì¼ìš”ì¼(6)
            # ë‹¤ìŒ ì›”ìš”ì¼ ê³„ì‚°
            days_until_monday = 7 - now.weekday()
            next_monday = now + timedelta(days=days_until_monday)
            target_time = next_monday.replace(hour=target_hour, minute=target_minute, second=0, microsecond=0)
        else:
            # í‰ì¼
            target_time = now.replace(hour=target_hour, minute=target_minute, second=0, microsecond=0)

            # ì´ë¯¸ ëª©í‘œ ì‹œê°„ì„ ì§€ë‚¬ìœ¼ë©´ ë‹¤ìŒë‚ 
            if now >= target_time:
                target_time += timedelta(days=1)
                # ê¸ˆìš”ì¼ì´ë©´ ë‹¤ìŒ ì›”ìš”ì¼ë¡œ
                if target_time.weekday() >= 5:
                    days_until_monday = 7 - target_time.weekday()
                    target_time += timedelta(days=days_until_monday)

        # ì²˜ìŒ í•œ ë²ˆë§Œ ëª©í‘œ ì‹œê°„ ì¶œë ¥ (ìˆœìˆ˜ print ì‚¬ìš© - Richì™€ ì¶©ëŒ ë°©ì§€)
        print(f"â° ëª©í‘œ: {target_time.strftime('%m/%d %H:%M')} ({target_time.strftime('%A')})")
        print(f"ğŸ’¡ ì–¸ì œë“ ì§€ [Enter] í‚¤ë¥¼ ëˆŒëŸ¬ ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
        print()  # í•œ ì¤„ ë„ìš°ê¸°

        # ëŒ€ê¸° ë£¨í”„
        while self.running:
            now = datetime.now()
            time_diff = (target_time - now).total_seconds()

            if time_diff <= 0:
                # ì¤„ë°”ê¿ˆ í›„ ì™„ë£Œ ë©”ì‹œì§€
                print()
                console.print(f"[green]âœ“ {target_hour:02d}:{target_minute:02d} ë„ë‹¬![/green]")
                break

            # ì¢…ë£Œ ì‹ í˜¸ í™•ì¸
            if not self.running:
                print()
                console.print("[yellow]âš ï¸  ëŒ€ê¸° ì¤‘ ì¢…ë£Œ ì‹ í˜¸ ìˆ˜ì‹ [/yellow]")
                break

            hours = int(time_diff // 3600)
            minutes = int((time_diff % 3600) // 60)

            # ê°™ì€ ì¤„ì—ì„œ ì—…ë°ì´íŠ¸ (carriage return ì‚¬ìš©)
            sys.stdout.write(f"\râ° ëŒ€ê¸° ì¤‘... ë‚¨ì€ ì‹œê°„: {hours:02d}ì‹œê°„ {minutes:02d}ë¶„ ([Enter]ë¡œ ì¢…ë£Œ)   ")
            sys.stdout.flush()

            # Enter í‚¤ ì…ë ¥ í™•ì¸ (non-blocking)
            try:
                # 1ì´ˆ ë™ì•ˆ ì…ë ¥ ëŒ€ê¸°
                for _ in range(60):  # 60ì´ˆ = 1ë¶„
                    if not self.running:
                        break

                    # stdinì— ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸ (Unix/Linux)
                    if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
                        line = sys.stdin.readline()
                        if line:  # Enter í‚¤ ê°ì§€
                            print()
                            console.print("[yellow]âš ï¸  ì‚¬ìš©ìê°€ ëŒ€ê¸°ë¥¼ ì¤‘ë‹¨í–ˆìŠµë‹ˆë‹¤.[/yellow]")
                            self.running = False
                            break

                    await asyncio.sleep(1)  # 1ì´ˆ ëŒ€ê¸°
            except Exception:
                # selectê°€ ì‘ë™í•˜ì§€ ì•ŠëŠ” í™˜ê²½ (Windows ë“±)ì—ì„œëŠ” ê¸°ë³¸ sleep
                await asyncio.sleep(60)

    async def daily_routine(self):
        """ì¼ì¼ ë£¨í‹´ ì‹¤í–‰ (í•˜ë£¨ì— í•œ ë²ˆë§Œ)"""
        console.print()
        console.print("=" * 120, style="bold yellow")
        console.print(f"{'ğŸ“… ì¼ì¼ ìë™ë§¤ë§¤ ë£¨í‹´ ì‹œì‘':^120}", style="bold yellow")
        console.print("=" * 120, style="bold yellow")
        console.print()

        # 1. 08:50ê¹Œì§€ ëŒ€ê¸° (ì´ë¯¸ ì§€ë‚¬ìœ¼ë©´ ë°”ë¡œ ì‹œì‘)
        now = datetime.now()
        target_time = now.replace(hour=8, minute=50, second=0, microsecond=0)

        if self.skip_wait:
            # í…ŒìŠ¤íŠ¸ ëª¨ë“œ: ëŒ€ê¸° ê±´ë„ˆë›°ê¸°
            console.print(f"[cyan]â© í…ŒìŠ¤íŠ¸ ëª¨ë“œ: ëŒ€ê¸° ì‹œê°„ ê±´ë„ˆë›°ê¸° (ì¦‰ì‹œ ì‹œì‘)[/cyan]")
            console.print()
        elif now < target_time:
            # ì•„ì§ 08:50 ì „ì´ë©´ ëŒ€ê¸°
            await self.wait_until_time(8, 50)
        else:
            # ì´ë¯¸ 08:50 ì§€ë‚¬ìœ¼ë©´ ë°”ë¡œ ì‹œì‘
            console.print(f"[cyan]â° í˜„ì¬ ì‹œê°„: {now.strftime('%H:%M')} - ë°”ë¡œ í•„í„°ë§ ì‹œì‘í•©ë‹ˆë‹¤.[/cyan]")
            console.print()

        try:
            # 2. DBì—ì„œ í™œì„± ê°ì‹œ ì¢…ëª© ë¡œë“œ
            console.print("\n[0ë‹¨ê³„] DBì—ì„œ í™œì„± ê°ì‹œ ì¢…ëª© ë¡œë“œ")
            self.load_candidates_from_db()

            # 3. WebSocket ì—°ê²° ë° ë¡œê·¸ì¸
            console.print("\n[1ë‹¨ê³„] ì‹œìŠ¤í…œ ì´ˆê¸°í™”")
            await self.connect()

            if not await self.login():
                console.print("[red]âŒ ë¡œê·¸ì¸ ì‹¤íŒ¨. ë‚´ì¼ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.[/red]")
                return

            # 4. ê³„ì¢Œ ì •ë³´ ì´ˆê¸°í™”
            await self.initialize_account()

            # 4. ì¡°ê±´ì‹ ëª©ë¡ ì¡°íšŒ
            if not await self.get_condition_list():
                console.print("[red]âŒ ì¡°ê±´ì‹ ì¡°íšŒ ì‹¤íŒ¨. ë‚´ì¼ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.[/red]")
                return

            # 5. 1ì°¨ + 2ì°¨ í•„í„°ë§ (08:50 ~ 09:00)
            console.print("\n[2ë‹¨ê³„] í•„í„°ë§ ì‹œì‘ (08:50)")
            await self.run_condition_filtering()

            # ì„ ì • ì¢…ëª©ì´ ì—†ìœ¼ë©´ ì˜¤ëŠ˜ì€ ì¢…ë£Œ
            if not self.watchlist:
                console.print("[yellow]âš ï¸  ì„ ì •ëœ ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤. ì˜¤ëŠ˜ ê±°ë˜ ì—†ìŒ.[/yellow]")
                return

            # 6. WebSocket ì¢…ë£Œ (REST APIë§Œ ì‚¬ìš©)
            if self.websocket:
                await self.websocket.close()

            # 7. 09:00ê¹Œì§€ ëŒ€ê¸° (ì´ë¯¸ ì§€ë‚¬ìœ¼ë©´ ë°”ë¡œ ì‹œì‘)
            now = datetime.now()
            market_open = now.replace(hour=9, minute=0, second=0, microsecond=0)

            if self.skip_wait:
                # í…ŒìŠ¤íŠ¸ ëª¨ë“œ: ëŒ€ê¸° ê±´ë„ˆë›°ê¸°
                console.print(f"[cyan]â© í…ŒìŠ¤íŠ¸ ëª¨ë“œ: 09:00 ëŒ€ê¸° ê±´ë„ˆë›°ê¸°[/cyan]")
                console.print()
            elif now < market_open:
                # ì•„ì§ 09:00 ì „ì´ë©´ ëŒ€ê¸°
                await self.wait_until_time(9, 0)
            else:
                # ì´ë¯¸ 09:00 ì§€ë‚¬ìœ¼ë©´ ë°”ë¡œ ì‹œì‘
                console.print(f"[cyan]â° í˜„ì¬ ì‹œê°„: {now.strftime('%H:%M')} - ë°”ë¡œ ëª¨ë‹ˆí„°ë§ ì‹œì‘í•©ë‹ˆë‹¤.[/cyan]")
                console.print()

            # 8. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ë° ë§¤ë§¤ (09:00 ~ 15:30)
            console.print("\n[3ë‹¨ê³„] ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘")
            await self.monitor_and_trade()

        except Exception as e:
            console.print(f"[red]âŒ ë£¨í‹´ ì‹¤í–‰ ì˜¤ë¥˜: {e}[/red]")
            import traceback
            traceback.print_exc()
        finally:
            # WebSocket ì •ë¦¬
            if self.websocket:
                await self.websocket.close()

    async def run(self):
        """ì „ì²´ ì‹œìŠ¤í…œ ì‹¤í–‰ (ë¬´í•œ ë°˜ë³µ)"""
        console.print()
        console.print("=" * 120, style="bold green")
        console.print(f"{'ğŸš€ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ ì‹œì‘ (ìŠ¤ì¼€ì¤„ë§ ëª¨ë“œ)':^120}", style="bold green")
        console.print("=" * 120, style="bold green")
        console.print()
        console.print("[cyan]ë§¤ì¼ 08:50 í•„í„°ë§ â†’ 09:00 ëª¨ë‹ˆí„°ë§ ì‹œì‘[/cyan]")
        console.print("[dim]Ctrl+Cë¥¼ ëˆŒëŸ¬ ì¢…ë£Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.[/dim]")
        console.print()

        try:
            while self.running:
                # ì¼ì¼ ë£¨í‹´ ì‹¤í–‰ (08:50ë¶€í„° 15:30ê¹Œì§€)
                await self.daily_routine()

                # ì¢…ë£Œ ì‹ í˜¸ í™•ì¸
                if not self.running:
                    break

                # ë£¨í‹´ ì¢…ë£Œ í›„ ë‹¤ìŒë‚  08:50ê¹Œì§€ ëŒ€ê¸°
                console.print()
                console.print("[green]âœ… ì˜¤ëŠ˜ ê±°ë˜ ì¢…ë£Œ[/green]")
                console.print("[cyan]ğŸ’¤ ë‚´ì¼ 08:50ê¹Œì§€ ëŒ€ê¸°í•©ë‹ˆë‹¤...[/cyan]")
                console.print()

                # ë‹¤ìŒë‚  08:50ê¹Œì§€ ëŒ€ê¸°
                now = datetime.now()
                tomorrow = now + timedelta(days=1)
                next_run = tomorrow.replace(hour=8, minute=50, second=0, microsecond=0)

                wait_seconds = (next_run - now).total_seconds()
                console.print(f"[dim]ë‹¤ìŒ ì‹¤í–‰ ì‹œê°: {next_run.strftime('%Y-%m-%d %H:%M')} (ì•½ {wait_seconds/3600:.1f}ì‹œê°„ í›„)[/dim]")

                # 1ì‹œê°„ ë‹¨ìœ„ë¡œ ì²´í¬í•˜ë©´ì„œ ëŒ€ê¸°
                while self.running and datetime.now() < next_run:
                    await asyncio.sleep(min(3600, wait_seconds))  # ìµœëŒ€ 1ì‹œê°„ì”© ëŒ€ê¸°
                    if not self.running:
                        break

        except KeyboardInterrupt:
            console.print()
            console.print("[yellow]âš ï¸  ì‚¬ìš©ìê°€ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤.[/yellow]")
        except Exception as e:
            console.print(f"[red]âŒ ì‹œìŠ¤í…œ ì˜¤ë¥˜: {e}[/red]")
            import traceback
            traceback.print_exc()
        finally:
            if self.websocket:
                await self.websocket.close()


async def main(skip_wait: bool = False):
    """ë©”ì¸ ì‹¤í–‰

    Args:
        skip_wait: Trueë©´ ëŒ€ê¸° ì‹œê°„ì„ ê±´ë„ˆë›°ê³  ì¦‰ì‹œ ì‹¤í–‰ (í…ŒìŠ¤íŠ¸ ëª¨ë“œ)
    """
    import argparse
    import sys

    # Argparse ì²˜ë¦¬ (ì»¤ë§¨ë“œë¼ì¸ ì‹¤í–‰ ì‹œ)
    args = None
    condition_indices = None

    if len(sys.argv) > 1:
        # ì»¤ë§¨ë“œë¼ì¸ ì¸ìê°€ ìˆìœ¼ë©´ argparse ì‚¬ìš©
        if True:
            parser = argparse.ArgumentParser(
                description='í‚¤ì›€ ì¡°ê±´ì‹ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ (SignalOrchestrator L0-L6 í†µí•©)',
                formatter_class=argparse.RawDescriptionHelpFormatter,
                epilog="""
ì‚¬ìš© ì˜ˆì‹œ:
  # ë°±í…ŒìŠ¤íŠ¸ ê²€ì¦ (ì¡°ê±´ì‹ 0,1,2 ì‚¬ìš©)
  python3 main_auto_trading.py --dry-run --conditions 0,1,2

  # ì‹¤ì „ íˆ¬ì… (ì¡°ê±´ì‹ 0,1,2,3,4,5 ì‚¬ìš©)
  python3 main_auto_trading.py --live --conditions 0,1,2,3,4,5

  # í…ŒìŠ¤íŠ¸ ëª¨ë“œ (ëŒ€ê¸° ì‹œê°„ ê±´ë„ˆë›°ê¸°)
  python3 main_auto_trading.py --skip-wait --conditions 0,1,2
                """
            )
            parser.add_argument('--skip-wait', action='store_true',
                               help='í…ŒìŠ¤íŠ¸ ëª¨ë“œ: ëŒ€ê¸° ì‹œê°„ì„ ê±´ë„ˆë›°ê³  ì¦‰ì‹œ ì‹¤í–‰')
            parser.add_argument('--dry-run', action='store_true',
                               help='ë°±í…ŒìŠ¤íŠ¸ ê²€ì¦ ëª¨ë“œ (ì‹¤ì œ ë§¤ë§¤ ì—†ì´ ì‹œê·¸ë„ë§Œ í™•ì¸)')
            parser.add_argument('--live', action='store_true',
                               help='ì‹¤ì „ íˆ¬ì… ëª¨ë“œ (ì‹¤ì œ ë§¤ë§¤ ì‹¤í–‰)')
            parser.add_argument('--conditions', type=str, default='17,18,19,20,21,22',
                               help='ì‚¬ìš©í•  ì¡°ê±´ì‹ ì¸ë±ìŠ¤ (ì‰¼í‘œë¡œ êµ¬ë¶„, ê¸°ë³¸ê°’: 17,18,19,20,21,22)')
            args = parser.parse_args()

            # conditions íŒŒì‹±
            try:
                condition_indices = [int(x.strip()) for x in args.conditions.split(',')]
            except:
                console.print("[red]âŒ --conditions íŒŒë¼ë¯¸í„° ì˜¤ë¥˜: ì‰¼í‘œë¡œ êµ¬ë¶„ëœ ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: 0,1,2)[/red]")
                return

    # args ê°ì²´ ìƒì„± (main_menu.py í˜¸ì¶œ ì‹œ)
    if args is None:
        class Args:
            pass
        args = Args()
        args.skip_wait = skip_wait
        args.dry_run = False
        args.live = False
        args.conditions = '17,18,19,20,21,22'

        # conditions íŒŒì‹±
        try:
            condition_indices = [int(x.strip()) for x in args.conditions.split(',')]
        except:
            console.print("[red]âŒ --conditions íŒŒë¼ë¯¸í„° ì˜¤ë¥˜[/red]")
            return

    console.print()
    console.print("=" * 120, style="bold green")
    console.print(f"{'í‚¤ì›€ ì¡°ê±´ì‹ â†’ VWAP í•„í„°ë§ â†’ ìë™ë§¤ë§¤ í†µí•© ì‹œìŠ¤í…œ (L0-L6)':^120}", style="bold green")
    console.print("=" * 120, style="bold green")
    console.print()

    # ëª¨ë“œ í‘œì‹œ
    if args.dry_run:
        console.print("[cyan]ğŸ” ë°±í…ŒìŠ¤íŠ¸ ê²€ì¦ ëª¨ë“œ: ì‹¤ì œ ë§¤ë§¤ ì—†ì´ ì‹œê·¸ë„ë§Œ í™•ì¸[/cyan]")
        console.print()
    elif args.live:
        console.print("[red]ğŸš€ ì‹¤ì „ íˆ¬ì… ëª¨ë“œ: ì‹¤ì œ ë§¤ë§¤ ì‹¤í–‰![/red]")
        console.print()

    if args.skip_wait:
        console.print("[yellow]âš¡ í…ŒìŠ¤íŠ¸ ëª¨ë“œ í™œì„±í™”: ëŒ€ê¸° ì‹œê°„ ê±´ë„ˆë›°ê¸°[/yellow]")
        console.print()

    # ì¡°ê±´ì‹ í‘œì‹œ
    console.print(f"[dim]ì‚¬ìš© ì¡°ê±´ì‹ ì¸ë±ìŠ¤: {condition_indices}[/dim]")
    console.print()

    # API í´ë¼ì´ì–¸íŠ¸ ìƒì„±
    console.print("[ì´ˆê¸°í™”] API í´ë¼ì´ì–¸íŠ¸ ìƒì„±")
    api = KiwoomAPI()
    console.print("  âœ“ ì™„ë£Œ")
    console.print()

    # AccessToken ë°œê¸‰
    console.print("[ì´ˆê¸°í™”] AccessToken ë°œê¸‰")
    api.get_access_token()

    if not api.access_token:
        console.print("[red]âŒ í† í° ë°œê¸‰ ì‹¤íŒ¨[/red]")
        return

    console.print("  âœ“ ì™„ë£Œ")
    console.print()

    # í†µí•© ì‹œìŠ¤í…œ ìƒì„± ë° ì‹¤í–‰
    console.print(f"[ì´ˆê¸°í™”] í†µí•© ì‹œìŠ¤í…œ ìƒì„± (ì¡°ê±´ì‹ {len(condition_indices)}ê°œ)")
    system = IntegratedTradingSystem(api.access_token, api, condition_indices, skip_wait=args.skip_wait)
    console.print("  âœ“ ì™„ë£Œ")
    console.print()

    # dry-run ëª¨ë“œ ì„¤ì •
    if args.dry_run:
        system.dry_run_mode = True
        console.print("[cyan]ğŸ’¡ ë°±í…ŒìŠ¤íŠ¸ ëª¨ë“œ: ì‹¤ì œ ë§¤ë§¤ ì—†ì´ ì‹œê·¸ë„ë§Œ ë¡œê·¸ë¡œ ê¸°ë¡í•©ë‹ˆë‹¤.[/cyan]")
        console.print()

    # Ctrl+C í•¸ë“¤ëŸ¬ ë“±ë¡ (ì—°ì† 2ë²ˆìœ¼ë¡œ ê°•ì œ ì¢…ë£Œ)
    ctrl_c_count = 0
    import time as time_module
    last_ctrl_c_time = 0

    def signal_handler(sig, frame):
        nonlocal ctrl_c_count, last_ctrl_c_time
        current_time = time_module.time()

        # 3ì´ˆ ì´ë‚´ ì—°ì† Ctrl+C ì²´í¬
        if current_time - last_ctrl_c_time < 3:
            ctrl_c_count += 1
        else:
            ctrl_c_count = 1

        last_ctrl_c_time = current_time

        console.print()
        console.print(f"[yellow]âš ï¸  ì¢…ë£Œ ì‹ í˜¸ ìˆ˜ì‹  ({ctrl_c_count}ë²ˆ)[/yellow]")

        if ctrl_c_count >= 2:
            console.print("[red]ğŸ›‘ ê°•ì œ ì¢…ë£Œí•©ë‹ˆë‹¤...[/red]")
            import sys
            sys.exit(0)
        else:
            console.print("[dim]ì •ìƒ ì¢…ë£Œ ì¤‘... (ë‹¤ì‹œ Ctrl+Cë¥¼ ëˆ„ë¥´ë©´ ê°•ì œ ì¢…ë£Œ)[/dim]")
            system.running = False

    signal.signal(signal.SIGINT, signal_handler)

    # ì‹œìŠ¤í…œ ì‹¤í–‰
    await system.run()


if __name__ == "__main__":
    # ì§ì ‘ ì‹¤í–‰ ì‹œ argparseê°€ ì²˜ë¦¬í•˜ë¯€ë¡œ skip_wait=Falseë¡œ ì‹œì‘
    asyncio.run(main(skip_wait=False))
